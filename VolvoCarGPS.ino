// Volvo Car GPS with Touch Screen UI
#include <SPI.h>
#include <Adafruit_GPS.h>
#include <SoftwareSerial.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_TFTLCD.h> // Hardware-specific library
#include <avr/sleep.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_FT6206.h>
#include <math.h>

// Pins
#define LCD_CS    A3 // Chip Select goes to Analog 3
#define LCD_CD    A2 // Command/Data goes to Analog 2
#define LCD_WR    A1 // LCD Write goes to Analog 1
#define LCD_RD    A0 // LCD Read goes to Analog 0
#define LCD_RESET A4 // Can alternately just connect to Arduino's reset pin

#define ONE_WIRE_BUS  31
#define BACKLIGHT_PIN 44
#define CHIPSELECT    10
#define LEDPIN        13
#define DISPLAYBUTTON 40

// Options
#define GPSECHO               true
#define LOG_FIXONLY           false
#define TEMPERATURE_PRECISION 11
#define MAX_SPEED 90

// The size of the screen
#define SCREEN_WIDTH  320
#define SCREEN_HEIGHT 240

// Colors
#define	BLACK   0x0000
#define	BLUE    0x001F
#define	RED     0xF800
#define	GREEN   0xDFEF
#define CYAN    0x07FF
#define MAGENTA 0xF81F
#define YELLOW  0xFFE0
#define WHITE   0xFFFF
#define GREY    0xE71C

enum Error {
	INIT_ERROR,
	FILE_ERROR,
	WRITE_ERROR
};

Adafruit_GPS      GPS(&Serial1);                                      // Library driver for the GPS.
Adafruit_TFTLCD   display(LCD_CS, LCD_CD, LCD_WR, LCD_RD, LCD_RESET); // Library driver for the TFT LCD.
Adafruit_FT6206   ts = Adafruit_FT6206();                             // Library driver for the touch.
OneWire           oneWire(ONE_WIRE_BUS);                              // Library for the digital temperature sensor.
DallasTemperature sensors(&oneWire);                                  // Library for the digital temperature sensor.
DeviceAddress     tempDeviceAddress;                                  // Library for the digital temperature sensor.
File              logfile;                                            // The file to write to.

int          currentScreen = 0;         // The current screen that is displayed.

double       maxAlt = -3.4028235E+38,   // Maximum altitude since reset.
             minAlt = 3.4028235E+38,    // Minimum altitude since reset.
             maxSpeed = -3.4028235E+38, // Maximum speed since reset.
             avgSpeed,                  // Average speed since reset.
             maxTemp = -3.4028235E+38,  // Maximum temperature since reset.
             minTemp = 3.4028235E+38,   // Minimum temperature since reset.
             currTemp,                  // Current temperature.
             currAlt,                   // Current altitude.
             currSpeed;                 // Current speed.

bool         wasPressed = false,        // Tells if the screen has already been pressed.
             gotFix = false,            // Tells if the GPS has gotten a fix since start.
             usingInterrupt = false,    // Tells if we should use interrupts for parsing NMEA data.
             refresh = true;            // Tells if we should refresh the screen.

unsigned int trkpts = 0,                // The number of track points in the current log file.
             logs = 0;                  // The number of the log on the SD card currently written to.

static const unsigned char PROGMEM volvo [] = {
	B11111111, B11111111, B11000111, B11111111, B10000011, B11111111, B00000001, B11111111, B11111110, B00111111, B11111111, B11110001,B11111111, B10000011, B11111111, B11110000,
	B11111111, B11111111, B11000111, B11111111, B10011111, B11111111, B11000001, B11111111, B11111110, B00111111, B11111111, B11110001,B11111111, B10011111, B11111111, B11111100,
	B11111111, B11111111, B11000111, B11111111, B10111111, B11111111, B11110001, B11111111, B11111110, B00111111, B11111111, B11110001,B11111111, B10111111, B11111111, B11111110,
	B11111111, B11111111, B11000111, B11111111, B11111111, B11111111, B11111001, B11111111, B11111110, B00111111, B11111111, B11110001,B11111111, B11111111, B11100001, B11111111,
	B00000111, B11111110, B00000001, B11111000, B11111111, B10000111, B11111100, B00011111, B11100000, B00000001, B11111111, B10000000,B01111100, B01111111, B11000001, B11111111,
	B00000111, B11111110, B00000011, B11110001, B11111111, B00000111, B11111100, B00011111, B11100000, B00000001, B11111111, B10000000,B11111100, B01111111, B11000000, B11111111,
	B00000011, B11111111, B00000011, B11110001, B11111111, B00000011, B11111110, B00011111, B11100000, B00000000, B11111111, B11000000,B11111000, B01111111, B11000000, B11111111,
	B00000011, B11111111, B00000111, B11100001, B11111111, B00000011, B11111110, B00011111, B11100000, B00000000, B11111111, B11000001,B11111000, B01111111, B11000000, B11111111,
	B00000001, B11111111, B10000111, B11100001, B11111111, B00000011, B11111110, B00011111, B11100000, B00000000, B01111111, B11100001,B11110000, B01111111, B11000000, B11111111,
	B00000001, B11111111, B11001111, B11000001, B11111111, B00000011, B11111110, B00011111, B11100000, B00011110, B01111111, B11110011,B11100000, B01111111, B11000000, B11111111,
	B00000000, B11111111, B11001111, B10000001, B11111111, B00000011, B11111110, B00011111, B11100000, B00011110, B00111111, B11110011,B11100000, B01111111, B11000000, B11111111,
	B00000000, B01111111, B11111111, B10000001, B11111111, B00000011, B11111110, B00011111, B11100000, B00011110, B00111111, B11111111,B11000000, B00111111, B11100001, B11111111,
	B00000000, B01111111, B11111111, B00000000, B11111111, B10000111, B11111100, B00011111, B11100000, B00111110, B00011111, B11111111,B11000000, B00111111, B11110011, B11111110,
	B00000000, B00111111, B11111111, B00000000, B11111111, B11001111, B11111000, B00011111, B11100000, B01111110, B00001111, B11111111,B10000000, B00011111, B11111111, B11111110,
	B00000000, B00111111, B11111110, B00000000, B01111111, B11111111, B11111001, B11111111, B11111111, B11111110, B00001111, B11111111,B10000000, B00001111, B11111111, B11111000,
	B00000000, B00011111, B11111110, B00000000, B00111111, B11111111, B11100001, B11111111, B11111111, B11111110, B00000111, B11111111,B00000000, B00000011, B11111111, B11100000,
	B00000000, B00011111, B11111100, B00000000, B00001111, B11111111, B10000001, B11111111, B11111111, B11111110, B00000111, B11111111,B00000000, B00000000, B00000000, B00000000};

const unsigned char  PROGMEM volvo_2_top [] = {
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11111111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00000001, B11111111, B11110000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11000000, B00000000, B00001111, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B11111111, B11111000, B00000000, B00000011, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000000, B11111111, B00000000, B01111111, B11111111, B11111111, B11111111, B00000000, B00000001, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000011, B11111000, B00000000, B01111111, B11111111, B11111111, B11111111, B11000000, B00000000, B01111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00001111, B11000000, B00000000, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00111111, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11111100, B00000000, B00001111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B11111100, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11111110, B00000000, B00000111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000001, B11110000, B00000000, B00000111, B11111111, B11111111, B11111111, B11111111, B11111111, B10000000, B00110011, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000111, B11000000, B00000000, B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11100000, B01111001, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00001111, B10000000, B00000000, B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000, B11111110, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00011110, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111001, B11111111, B01111111, B11111100,
	B00000000, B00000000, B00000000, B01111100, B00000000, B00000000, B11111111, B00000000, B00000000, B11111111, B11111111, B11111111, B11110011, B11111111, B00111111, B11111100,
	B00000000, B00000000, B00000000, B11110000, B00000000, B00000011, B11100000, B00000000, B00000000, B00000111, B11111111, B11111111, B11100111, B11111111, B10011111, B11111100,
	B00000000, B00000000, B00000001, B11100000, B00000000, B00000111, B00000001, B11000000, B00000000, B00000000, B11111111, B11111111, B11001111, B11111111, B11001111, B11111100,
	B00000000, B00000000, B00000011, B11000000, B00000000, B00001100, B00011111, B11111100, B00000000, B00000000, B00111111, B11111111, B10011111, B11111111, B11100111, B11111100,
	B00000000, B00000000, B00000111, B10000000, B00000000, B00010000, B11111111, B11111111, B10000000, B00000000, B00000111, B11111111, B00111111, B11111111, B11110011, B11111100,
	B00000000, B00000000, B00001111, B00000000, B00000000, B00000011, B11111111, B11111111, B11100000, B00000000, B00000001, B11111110, B01111111, B11111111, B11111011, B11111100,
	B00000000, B00000000, B00011110, B00000000, B00000000, B00011111, B11111111, B11111111, B11110000, B00000000, B00000000, B11111110, B11111111, B11111111, B11111101, B11111100,
	B00000000, B00000000, B00111100, B00000000, B00000000, B00111111, B11111111, B11111111, B11111000, B00000000, B00000000, B00111111, B11111111, B11111111, B11111100, B11111100,
	B00000000, B00000000, B01111000, B00000000, B00000000, B11111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00011111, B11111111, B11111111, B11111110, B11111100,
	B00000000, B00000000, B11110000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000111, B11111111, B11111111, B11111100, B01111100,
	B00000000, B00000000, B11100000, B00000000, B00000111, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00000011, B11111111, B11111111, B11111000, B00111100,
	B00000000, B00000001, B11000000, B00000000, B00001111, B11111111, B11111111, B11100000, B00000111, B11111110, B00000000, B00000001, B11111111, B11111111, B11110000, B00111100,
	B00000000, B00000011, B10000000, B00000000, B00111111, B11111111, B11111100, B00000000, B00000000, B00111111, B10000000, B00000000, B11111111, B11111111, B11100000, B00011100,
	B00000000, B00000111, B10000000, B00000000, B01111111, B11111111, B11100000, B00000000, B00000000, B00000111, B11100000, B00000000, B01111111, B11111111, B11100000, B00001100,
	B00000000, B00000111, B00000000, B00000000, B11111111, B11111111, B10000000, B00000000, B00000000, B00000001, B11111000, B00000000, B00111111, B11111111, B11100000, B00001100,
	B00000000, B00001110, B00000000, B00000001, B11111111, B11111110, B00000000, B00000000, B00000000, B00000000, B01111100, B00000000, B00011111, B11111111, B11110000, B00000100,
	B00000000, B00001110, B00000000, B00000011, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00011110, B00000000, B00001111, B11111111, B11110000, B00000100,
	B00000000, B00011100, B00000000, B00000111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000111, B10000000, B00000111, B11111111, B11111000, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11000000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11100000, B00000001, B11111111, B11111100, B00000000,
	B00000000, B01110000, B00000000, B00011111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11110000, B00000001, B11111111, B11111110, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01111000, B00000000, B11111111, B11111110, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00111100, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011110, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11000000, B00000000, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001111, B00000000, B00111111, B11111111, B00000000,
	B00000001, B11000000, B00000000, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B00000000, B00111111, B11111111, B10000000,
	B00000001, B10000000, B00000001, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B10000000, B00011111, B11111111, B10000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00011111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00001111, B11111111, B11000000,
	B00000011, B00000000, B00000011, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00001111, B11111111, B11000000,
	B00000111, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000111, B11111111, B11100000,
	B00000111, B00000000, B00000111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000111, B11111111, B11100000,
	B00000111, B00000000, B00001111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000011, B11111111, B11100000,
};

const unsigned char  PROGMEM volvo_2_middle [] = {
	B00001111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00001111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00001111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B10000000, B00000001, B11000000, B00001111, B10000000, B11111110, B00000000, B00001110, B00000000, B00000111, B00000000, B00111110, B00000011, B11111111, B11111000,
	B00111111, B10000000, B00000001, B11000000, B00001100, B00000000, B00011110, B00000000, B00001110, B00000000, B00000111, B00000000, B00110000, B00000000, B01111111, B11111000,
	B00111111, B11110000, B00000111, B11110000, B01111000, B00001000, B00001111, B11000000, B00011111, B11000000, B00011111, B11000001, B11100000, B00100000, B00111111, B11111100,
	B00111111, B11111000, B00000111, B11110000, B01110000, B00011110, B00000111, B11000000, B01111111, B11100000, B00011111, B11000001, B11000000, B11111000, B00011111, B11111100,
	B00111111, B11111100, B00000011, B11110000, B11100000, B00111110, B00000011, B11000000, B01111111, B11110000, B00001111, B11000011, B10000000, B11111000, B00001111, B11111100,
	B00111111, B11111100, B00000011, B11100000, B11100000, B00111111, B00000011, B11000000, B01111111, B11110000, B00001111, B10000111, B10000000, B11111100, B00001111, B11111100,
	B00111111, B11111110, B00000001, B11100001, B11100000, B00111111, B00000011, B11000000, B01111111, B11111000, B00000111, B10000111, B10000000, B11111100, B00001111, B11111100,
	B00111111, B11111110, B00000001, B11000011, B11100000, B00111111, B00000011, B11000000, B01111111, B10011000, B00000111, B00001111, B10000000, B11111100, B00001111, B11111100,
	B00111111, B11111111, B00000000, B11000011, B11100000, B00111111, B00000011, B11000000, B01111111, B00011100, B00000011, B00001111, B10000000, B11111100, B00001111, B11111100,
	B00111111, B11111111, B00000000, B00000111, B11100000, B00111110, B00000011, B11000000, B01111111, B00011100, B00000000, B00011111, B10000000, B11111000, B00001111, B11111100,
	B00011111, B11111111, B10000000, B00000111, B11110000, B00011110, B00000111, B11000000, B01111110, B00011110, B00000000, B00011111, B11000000, B01111000, B00011111, B11111100,
	B00011111, B11111111, B11000000, B00001111, B11111000, B00001100, B00001111, B11000000, B00111000, B00011110, B00000000, B00111111, B11100000, B00110000, B00111111, B11111000,
	B00011111, B11111111, B11000000, B00001111, B11111100, B00000000, B00011110, B00000000, B00000000, B00011111, B00000000, B00111111, B11110000, B00000000, B01111111, B11111000,
	B00011111, B11111111, B11100000, B00011111, B11111111, B00000000, B01111110, B00000000, B00000000, B00011111, B10000000, B01111111, B11111100, B00000001, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00001111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00001111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00001111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000,
	B00000111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11100000,
};
const unsigned char  PROGMEM volvo_2_bottom [] = {
	B00000111, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000111, B11111111, B11100000,
	B00000011, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00001111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00001111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00011111, B11111111, B11000000,
	B00000001, B10000000, B00000001, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B10000000, B00011111, B11111111, B10000000,
	B00000001, B11000000, B00000001, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B00000000, B00111111, B11111111, B10000000,
	B00000001, B11000000, B00000000, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001111, B00000000, B00111111, B11111111, B10000000,
	B00000000, B11100000, B00000000, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001110, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011100, B00000000, B01111111, B11111111, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00111000, B00000000, B11111111, B11111110, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000001, B11111111, B11111110, B00000000,
	B00000000, B00111000, B00000000, B00011111, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11000000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00011100, B00000000, B00000111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000111, B10000000, B00000111, B11111111, B11111000, B00000000,
	B00000000, B00011100, B00000000, B00000011, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00011111, B00000000, B00001111, B11111111, B11111000, B00000000,
	B00000000, B00001110, B00000000, B00000001, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00111110, B00000000, B00011111, B11111111, B11110000, B00000000,
	B00000000, B00000111, B00000000, B00000000, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00111111, B11111111, B11100000, B00000000,
	B00000000, B00000111, B00000000, B00000000, B01111111, B11111111, B11100000, B00000000, B00000000, B00000011, B11100000, B00000000, B01111111, B11111111, B11100000, B00000000,
	B00000000, B00000011, B10000000, B00000000, B00111111, B11111111, B11111100, B00000000, B00000000, B00011111, B11000000, B00000000, B11111111, B11111111, B11000000, B00000000,
	B00000000, B00000001, B11000000, B00000000, B00011111, B11111111, B11111111, B10000000, B00000001, B11111110, B00000000, B00000001, B11111111, B11111111, B10000000, B00000000,
	B00000000, B00000001, B11100000, B00000000, B00001111, B11111111, B11111111, B11111111, B11111111, B11111000, B00000000, B00000111, B11111111, B11111111, B00000000, B00000000,
	B00000000, B00000000, B11110000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11100000, B00000000, B00001111, B11111111, B11111111, B00000000, B00000000,
	B00000000, B00000000, B01110000, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11000000, B00000000, B00011111, B11111111, B11111110, B00000000, B00000000,
	B00000000, B00000000, B00111000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B10000000, B00000000, B01111111, B11111111, B11111100, B00000000, B00000000,
	B00000000, B00000000, B00011100, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B00000000, B00000001, B11111111, B11111111, B11111000, B00000000, B00000000,
	B00000000, B00000000, B00001110, B00000000, B00000000, B00000111, B11111111, B11111111, B11111110, B00000000, B00000011, B11111111, B11111111, B11110000, B00000000, B00000000,
	B00000000, B00000000, B00000111, B00000000, B00000000, B00000000, B11111111, B11111111, B11111000, B00000000, B00011111, B11111111, B11111111, B11100000, B00000000, B00000000,
	B00000000, B00000000, B00000011, B10000000, B00000000, B00000000, B00011111, B11111111, B11100000, B00000000, B01111111, B11111111, B11111111, B11000000, B00000000, B00000000,
	B00000000, B00000000, B00000001, B11100000, B00000000, B00000000, B00000000, B11111111, B00000000, B00000011, B11111111, B11111111, B11111111, B10000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B01111000, B00000000, B00000000, B00000011, B10000000, B00000111, B11111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00111110, B00000000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B11111111, B11111100, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00001111, B00000000, B00000000, B00000000, B00001111, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000111, B11000000, B00000000, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11100000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000011, B11100000, B00000000, B00000000, B00000000, B00111111, B11111111, B11111111, B11111111, B10000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00000000, B00000000, B00000111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00111110, B00000000, B00000000, B00000000, B00000001, B11111111, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00001111, B11000000, B00000000, B00000000, B00000000, B01111111, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000111, B11110000, B00000000, B00000000, B00000000, B00111111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B11111110, B00000000, B00000000, B00000000, B01111111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00111111, B11100000, B00000000, B00000000, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111, B00000000, B00000011, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11111111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000
};



void printCenteredText(String text, int textSize, int color, int areaWidth, int offset, int y) {
	int x = (areaWidth-(text.length()*textSize*5+textSize*(text.length()-1)))/2+offset;
	display.setTextSize(textSize);
	display.setCursor(x,y);
	display.setTextColor(color);
	display.fillRect(offset+1,y,areaWidth-2,textSize*8, BLACK);
	display.print(text);
}

struct DisplayDate {
	int sec, min, hr, day, mth, yr, mil;

	DisplayDate(int yr, int mth, int day, int hr, int min, int sec, int mil) {
		this->yr  = yr;
		this->mth = mth;
		this->day = day;
		this->hr  = hr;
		this->min = min;
		this->sec = sec;
		this->mil = mil;
	}

	void updateDate(int yr, int mth, int day, int hr, int min, int sec, int mil) {
		this->yr  = yr;
		this->mth = mth;
		this->day = day;
		this->hr  = hr;
		this->min = min;
		this->sec = sec;
		this->mil = mil;
	}

	String getDate() {
		String date;
		this->day < 10 ? date.concat("0"):false;
		date.concat(String(day));
		date.concat(".");
		this->mth < 10 ? date.concat("0"):false;
		date.concat(String(mth));
		date.concat(".");
		date.concat("20");
		date.concat(String(yr));
		return date;
	}

	String getTime() {
		String date;
		this->hr < 10 ? date.concat("0"):false;
		date.concat(String(hr));
		date.concat(":");
		this->min < 10 ? date.concat("0"):false;
		date.concat(String(min));
		date.concat(":");
		this->sec < 10 ? date.concat("0"):false;
		date.concat(String(sec));
		return date;
	}

	String getISOTimestamp() {
		String isoDate;
		isoDate.concat("20");
		if (this->yr < 10) isoDate.concat('0');
		isoDate.concat(this->yr);
		isoDate += "-";

		if (this->mth < 10) isoDate.concat('0');
		isoDate.concat(this->mth);
		isoDate.concat('-');

		if (this->day < 10) isoDate.concat('0');
		isoDate.concat(this->day);

		isoDate.concat('T');

		if (this->hr < 10) isoDate.concat('0');
		isoDate.concat(this->hr);
		isoDate.concat(':');

		if (this->min < 10) isoDate.concat('0');
		isoDate.concat(this->min);
		isoDate.concat(':');

		if (this->sec < 10) isoDate.concat('0');
		isoDate.concat(this->sec);
		isoDate.concat('.');

		isoDate.concat(this->mil);
		isoDate.concat('Z');
		return isoDate;
	}
};
DisplayDate newDate(GPS.year, GPS.month, GPS.day, GPS.hour, GPS.minute, GPS.seconds, GPS.milliseconds);
DisplayDate oldDate(0,0,0,0,0,0,0);

struct GPS_Status
{
	DisplayDate date();

	double speed,
	       angle,
	       temperature,
	       altitude,
	       acceleration,
	       hdop,
	       points,
	       distance,
	       avgSpeed,
	       maxSpeed,
	       lat,
	       lon;

	bool refresh;

	int satellites,
	    fix;


	GPS_Status() {
		this->speed = NULL;
		this->angle = NULL;
		this->temperature = NULL;
		this->altitude = NULL;
		this->acceleration = NULL;
		this->hdop = NULL;
		this->points = NULL;
		this->distance = NULL;
		this->avgSpeed = NULL;
		this->maxSpeed = NULL;
		this->lat = NULL;
		this->lon = NULL;
	}

	GPS_Status(double speed, double angle, double temperature, double altitude, double acceleration, double hdop, double points, double distance, double avgSpeed, double maxSpeed, double lat, double lon, int satellites, int fix, bool refresh) {
		this->speed        = speed;
		this->angle        = angle;
		this->temperature  = temperature;
		this->altitude     = altitude;
		this->acceleration = acceleration;
		this->hdop         = hdop;
		this->points       = points;
		this->distance     = distance;
		this->avgSpeed     = avgSpeed;
		this->maxSpeed     = maxSpeed;
		this->lat          = lat;
		this->lon          = lon;
		this->refresh      = refresh;
	}

	void updateStatus(double speed, double angle, double temperature, double altitude, double acceleration, double hdop, double points, double distance, double avgSpeed, double maxSpeed, double lat, double lon, int satellites, int fix, bool refresh) {
		this->speed        = speed;
		this->angle        = angle;
		this->temperature  = temperature;
		this->altitude     = altitude;
		this->acceleration = acceleration;
		this->hdop         = hdop;
		this->points       = points;
		this->distance     = distance;
		this->avgSpeed     = avgSpeed;
		this->maxSpeed     = maxSpeed;
		this->lat          = lat;
		this->lon          = lon;
		this->refresh      = refresh;
	}
	void updateAvgSpeed(float avgSpeed) {
		this->avgSpeed = avgSpeed;
	}

	void updateMaxSpeed(float maxSpeed) {
		this->maxSpeed = maxSpeed;
	}

	void updateDistance(float distance) {
		this->distance = distance;
	}
};
GPS_Status newGpsStatus;
GPS_Status oldGpsStatus;

class Screen {
	public:
	virtual void displayScreen(GPS_Status* data, GPS_Status* oldData);
	//virtual bool wasTapped(int x, int y);
};
Screen*           screens[9];

class SummaryScreen: public Screen {

	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	double oldSpeed, oldAngle, oldTemperature, oldAltitude, oldAcceleration, oldHdop;
	int oldPoints = -1, oldSatellites;
	String oldDirection;

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, GREEN, 107, 0, 30);
		}
		double acceleration;
		if (speed != this->oldSpeed || newStatus->refresh) {
			if (speed < 10)                        printCenteredText(String(speed, 2), 3, GREEN, 107, 0, 64);
			else if (speed >= 10 && speed < 100)   printCenteredText(String(speed, 2), 3, GREEN, 107, 0, 64);
			else if (speed >= 100 && speed < 1000) printCenteredText(String(speed, 1), 3, GREEN, 107, 0, 64);
			else if (speed >= 1000)                printCenteredText(String(speed, 0), 3, GREEN, 107, 0, 64);

			acceleration = speed - this->oldSpeed;
			printCenteredText(String(acceleration, 2), 2, GREEN, 107, 0, 95);
		}

		this->oldSpeed = speed;
		this->oldAcceleration = acceleration;
	}

	void displayDirection(double angle) {

		if (newStatus->refresh) {
			printCenteredText("DIRECTION", 1, GREEN, 107, 107, 30);
		}

		String dir = getDirection(angle);

		if (this->oldDirection != dir || newStatus->refresh) {
			printCenteredText(dir, 3, GREEN, 107, 107, 64);
		}
		this->oldDirection = dir;

		if (this->oldAngle != angle || newStatus->refresh) {
			printCenteredText(String(angle), 2, GREEN, 107, 107, 95);
		}
		this->oldAngle = angle;
	}

	void displayTemperature(double temp) {
		if (newStatus->refresh) {
			printCenteredText("TEMPERATURE", 1, GREEN, 107, 214, 30);
		}

		if (this->oldTemperature != temp || newStatus->refresh) {

			if (currTemp != -3.4028235E+38) {
				if      (temp <= -100 || temp >= 1000)   printCenteredText(String(temp, 0), 3, GREEN, 107, 214, 64);
				else if ((temp <= -10 && temp > -100) ||
				         (temp >= 100 && temp < 1000))   printCenteredText(String(temp, 1), 3, GREEN, 107, 214, 64);
				else if (-10 < temp && temp < 100)       printCenteredText(String(temp, 2), 3, GREEN, 107, 214, 64);
			} else {
				printCenteredText("DISC", 3, GREEN, 107, 214, 64);
			}
		}
		this->oldTemperature = temp;
	}

	void displayAltitude(double alt) {
		if (newStatus->refresh) {
			display.setCursor(30,128);
			display.setTextSize(1);
			display.print("ALTITUDE");
		}
		if (this->oldAltitude != alt || newStatus->refresh) {
			if      (alt <= -100 || alt >= 1000)   printCenteredText(String(alt, 0), 3, GREEN, 107, 214, 162);
			else if ((alt <= -10 && alt > -100) ||
			         (alt >= 100 && alt < 1000))   printCenteredText(String(alt, 1), 3, GREEN, 107, 0, 162);
			else if (-10 < alt && alt < 100)       printCenteredText(String(alt, 2), 3, GREEN, 107, 0, 162);
		}
		this->oldAltitude = alt;
	}

	void displaySatellites(int sat, float hdop) {
		if (newStatus->refresh) {
			display.setCursor(131,128);
			printCenteredText("SATELLITES", 1, GREEN, 107, 107, 128);
		}

		if (this->oldSatellites != sat || newStatus->refresh) {
			printCenteredText(String(sat), 3, GREEN, 107, 107, 162);
		}
		this->oldSatellites = sat;

		if (this->oldHdop !=hdop || newStatus->refresh) {
			printCenteredText(String(hdop, 2), 2, GREEN, 107, 107, 193);
		}
		this->oldHdop = hdop;
	}

	void displayLogsAndPoints(int logNumber, int point) {
		if (newStatus->refresh) {
			printCenteredText("LOG", 1, GREEN, 107, 214, 128);
			printCenteredText("POINTS", 1, GREEN, 107, 214, 174);
			printCenteredText(String(logNumber), 2, GREEN, 107, 214, 142);
		}

		if (this->oldPoints != point || newStatus->refresh) {
			printCenteredText(String(point), 2, GREEN, 107, 214, 188);
		}
		this->oldPoints = point;
	}

	void displayOutlines() {
		if (newStatus->refresh) {
			display.drawLine(107,20, 107, 215, GREEN);
			display.drawLine(213,20, 213, 215, GREEN);
			display.drawLine(0, 118, 320, 118, GREEN);
			display.drawLine(0, 215, 320, 215, GREEN);
		}
	}

	void displayGPSStatus(int fix, double lat, double lon) {
		display.setTextColor(GREEN);
		display.setTextSize(2);

		if (GPS.fix) {
			display.setCursor(35,221);
			gotFix = true;
			if (newGpsStatus.lat != oldGpsStatus.lat ||
				newGpsStatus.lon != oldGpsStatus.lon || newStatus->refresh) {

				display.fillRect(35,221,250,16, BLACK);
				display.print(GPS.lat);
				display.print(" ");
				GPS.lat == 'N' ? display.print(GPS.latitudeDegrees, 4) : display.print((-1)*GPS.latitudeDegrees, 4);
				display.print("   ");
				display.print(GPS.lon);
				display.print(" ");
				GPS.lon == 'W' ? display.print((-1)*GPS.longitudeDegrees, 4) : display.print(GPS.longitudeDegrees, 4);
			}
		}
		else {

			if (newGpsStatus.fix != oldGpsStatus.fix || newStatus->refresh)
			{
				display.fillRect(0,216,320,25, BLACK);
				if (!gotFix) {
					display.setCursor(41,221);
					display.setTextColor(BLUE);
					display.print("Acquiring Satellites");
				} else {
					display.setCursor(71,221);
					display.setTextColor(RED);
					display.print("Lost Satellites");
				}
			}

		}
	}
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData) {
		this->newStatus = data;
		this->oldStatus = oldData;

		displayOutlines();
		displaySpeed(GPS.speed*1.852);
		displayDirection(GPS.angle);
		displayTemperature(currTemp);
		displayAltitude(GPS.altitude);
		displaySatellites(GPS.satellites, GPS.HDOP);
		displayLogsAndPoints(logs,this->newStatus->points);
		displayGPSStatus(GPS.fix, GPS.latitudeDegrees, GPS.longitudeDegrees);
	}

	bool wasTapped(int x, int y) {
		return false;
	}
};

class SpeedScreen: public Screen {
	float oldSpeed, oldAvgSpeed, oldMaxSpeed, oldDistance, oldAltitude;
	int oldSatellites;

	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displayDataFieldOutlines() {
		display.drawLine(0,60,340,60,GREEN);
		display.drawLine(0,100,80,100,GREEN);
		display.drawLine(240,100,320,100,GREEN);

		display.drawLine(80,20,80,100,GREEN);
		display.drawLine(160,20,160,60,GREEN);
		display.drawLine(240,20,240,100,GREEN);
	}
	void displaySpeedometerOutlines() {
		display.drawCircle(160,240,150,GREEN);
		for (int i = 1; i < MAX_SPEED; i++) {
			if (i % 10 == 0) {
				drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 135, GREEN);
				continue;
			}

			if (i % 5 == 0) {
				drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 140, GREEN);
				continue;
			}
			drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 145, GREEN);
		}
	}

	void displaySpeedometerUpdated(float speed, float avgSpeed, float maxSpeed) {
		display.setTextSize(1);
		display.setTextColor(GREEN);
		display.setCursor(40, 194);  display.print(10);
		display.setCursor(62, 157);  display.print(20);
		display.setCursor(92, 128);  display.print(30);
		display.setCursor(133, 113); display.print(40);
		display.setCursor(176, 113); display.print(50);
		display.setCursor(217, 128); display.print(60);
		display.setCursor(247, 157); display.print(70);
		display.setCursor(269, 194); display.print(80);
		display.drawBitmap(96, 170, volvo, 128, 17, BLUE);

		float mappedSpeed = mapfloat(speed, 0.0, MAX_SPEED, 180.0, 360.0);
		if (mappedSpeed < 180) mappedSpeed = 180;

		drawCircleLine(mapfloat(this->oldSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 0, 130, BLACK);
		drawCircleLine(mapfloat(speed,          0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 0, 130, RED);

		drawCircleLine(mapfloat(this->oldMaxSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLACK);
		drawCircleLine(mapfloat(maxSpeed,          0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, RED);

		drawCircleLine(mapfloat(this->oldAvgSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLACK);
		drawCircleLine(mapfloat(avgSpeed,          0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLUE);

		this->oldSpeed = speed;
		this->oldMaxSpeed = maxSpeed;
		this->oldAvgSpeed = avgSpeed;
	}

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, GREEN, 80, 0, 24);
		}
		if (oldSpeed != speed || newStatus->refresh) {
			printCenteredText(String(speed,2), 2, GREEN, 80, 0, 38);
		}
		this->oldSpeed = speed;
	}

	void displayAvgSpeed(float avgSpeed) {
		if (newStatus->refresh) {
			printCenteredText("AVG. SPEED", 1, GREEN, 79, 80, 24);
		}
		if (oldAvgSpeed != avgSpeed || newStatus->refresh) {
			printCenteredText(String(avgSpeed,2), 2, GREEN, 80, 80, 38);
		}
		this->oldAvgSpeed = avgSpeed;
	}

	void displayMaxSpeed(float maxSpeed) {
		if (newStatus->refresh) {
			printCenteredText("MAX SPEED", 1, GREEN, 79, 160, 24);
		}
		if (oldMaxSpeed != maxSpeed || newStatus->refresh) {
			printCenteredText(String(maxSpeed,2), 2, GREEN, 80, 160, 38);
		}
		this->oldMaxSpeed = maxSpeed;
	}

	void displayDistance(float distance) {
		if (newStatus->refresh) {
			printCenteredText("DISTANCE", 1, GREEN, 80, 240, 24);
		}
		if (oldDistance != distance || newStatus->refresh) {
			printCenteredText(String(distance, 2), 2, GREEN, 80, 240, 38);
		}
		this->oldDistance = distance;
	}

	void displayAltitude(float altitude) {
		if (newStatus->refresh) {
			printCenteredText("ALTITUDE", 1, GREEN, 80, 0, 65);
		}
		if (oldAltitude != altitude || newStatus->refresh) {
			printCenteredText(String(altitude,1), 2, GREEN, 80, 0, 79);
		}
		this->oldAltitude = altitude;
	}

	void displaySatellites(int satellites) {
		if (newStatus->refresh) {
			printCenteredText("SATELLITES", 1, GREEN, 80, 240, 65);
		}
		if (oldSatellites != satellites || newStatus->refresh) {
			printCenteredText(String(satellites), 2, GREEN, 80, 240, 79);
		}
		this->oldSatellites = satellites;
	}

	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData) {
		this->newStatus    = data;
		this->oldStatus = oldData;

		if (newStatus->refresh) {
			displayDataFieldOutlines();
		}
		displaySpeed(GPS.speed*1.852);
		displayAvgSpeed(newStatus->avgSpeed);
		displayMaxSpeed(newStatus->maxSpeed);
		displayDistance(newStatus->distance);
		displayAltitude(GPS.altitude);
		displaySatellites(GPS.satellites);
		if (newStatus->refresh) {
			displaySpeedometerOutlines();
		}
		displaySpeedometerUpdated(GPS.speed*1.852, newStatus->avgSpeed, newStatus->maxSpeed);

	}
	bool wasTapped(int x, int y) {
		return false;
	}
};

class DirectionScreen: public Screen {
	float oldAngle, oldSpeed, oldAltitude;
	String oldDirection;
	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displayDataFieldOutlines() {
		// Upper Horizontal Lines
		display.drawLine(0,   60, 80, 60,  GREEN);
		display.drawLine(240, 60, 320, 60, GREEN);

		// Upper Vertical Lines
		display.drawLine(80,20,80,60,GREEN);
		display.drawLine(240,20,240,60,GREEN);

		// Lower Horizontal Lines
		display.drawLine(0,200,80,200,GREEN);
		display.drawLine(240,200,320,200,GREEN);

		// Lower Vertical Lines
		display.drawLine(80,200,80,240,GREEN);
		display.drawLine(240,200,240,240,GREEN);
	}

	void displayDirection(float angle) {
		if (newStatus->refresh) {
			printCenteredText("DIRECTION", 1, GREEN, 80, 0,   24);
		}

		String dir = getDirection(angle);
		if (this->oldDirection != dir || newStatus->refresh) {
			printCenteredText(dir, 2, GREEN, 80, 0, 38);
		}
		this->oldDirection = dir;
	}

	void displayAngle(float angle) {
		if (newStatus->refresh) {
			printCenteredText("ANGLE", 1, GREEN, 80, 240, 24);
		}

		if (oldAngle != angle || newStatus->refresh) {
			printCenteredText(String(angle,1), 2, GREEN, 80, 240, 38);
		}

		this->oldAngle = angle;
	}

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, GREEN, 80, 0,   205);
		}

		if (oldSpeed != speed || newStatus->refresh) {
			printCenteredText(String(speed,2),    2, GREEN, 80, 0,   219);
		}

		this->oldSpeed = speed;
	}

	void displayAltitude(float altitude) {
		if (newStatus->refresh) {
			printCenteredText("ALTITUDE",  1, GREEN, 80, 240, 205);
		}

		if (oldAltitude != altitude || newStatus->refresh) {
			printCenteredText(String(altitude,2), 2, GREEN, 80, 240, 219);
		}

		this->oldAltitude = altitude;
	}

	void displayCompassOutline() {
		display.drawCircle(160, 130, 100, GREEN);

		display.drawLine  (259, 130, 250, 130, GREEN);
		display.drawLine  (230, 200, 224, 194, GREEN);
		display.drawLine  (160, 229, 160, 220, GREEN);
		display.drawLine  (90,  200, 96,  194, GREEN);
		display.drawLine  (61,  130, 70,  130, GREEN);
		display.drawLine  (90,  60,  96,  66,  GREEN);
		display.drawLine  (160, 31,  160, 40,  GREEN);
		display.drawLine  (230, 60,  224, 66,  GREEN);
		display.drawLine  (259, 130, 250, 130, GREEN);
	}

	void displayCompassDirection(float angle) {

		if (oldAngle != angle || newStatus->refresh) {
			display.drawLine(160,
			                 130,
			                (160 + (90 * cos((oldAngle * 1000.0 / 57296.0)-(PI/2)))),
			                (130 + (90 * sin((oldAngle * 1000.0 / 57296.0)-(PI/2)))),
			                 BLACK);

			display.drawLine(160,
			                 130,
			                (160 + (90 * cos((angle * 1000.0 / 57296.0)-(PI/2)))),
			                (130 + (90 * sin((angle * 1000.0 / 57296.0)-(PI/2)))),
			                 RED);
		}
		oldAngle = angle;
	}

	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData) {
		this->newStatus    = data;
		this->oldStatus = oldData;

		if (newStatus->refresh) {
			displayDataFieldOutlines();
			displayCompassOutline();
		}
		// Not the best solution.
		displayCompassDirection(GPS.angle);
		displayDirection(GPS.angle);
		displayAngle(GPS.angle);
		displaySpeed(GPS.speed*1.852);
		displayAltitude(GPS.altitude);
	}
};

class TemperatureScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData) {
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(GREEN);
			display.setCursor(3,23);
			display.print("Temperature:\nWork in progress...");
		}
	}
};

class AltitudeScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(GREEN);
			display.setCursor(3,23);
			display.print("Altitude:\nWork in progress...");
		}
	}
};

class SatellitesScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(GREEN);
			display.setCursor(3,23);
			display.print("Satellites:\nWork in progress...");
		}
	}
};

class LogsAndPointsScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){
		if (newStatus->refresh)
		{
			display.drawLine(0,130,320,130,GREEN);
			display.setTextSize(2);
			display.setTextColor(GREEN);
			display.setCursor(3,23);
			display.print("Time and position:\nWork in progress...");
		}
	}
};

class SettingsScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(GREEN);
			display.setCursor(3,23);
			display.print("Date and time:");
		}
		printCenteredText(newDate.getDate(), 5, GREEN, 320, 0, 75);
		printCenteredText(newDate.getTime(), 5, GREEN, 320, 0, 145);
		refresh = false;
	}
};

class BlankScreen: public Screen
{
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){}
};

void useInterrupt(boolean);

uint8_t parseHex(char c) {
	if (c < '0')
		return 0;
	if (c <= '9')
		return c - '0';
	if (c < 'A')
		return 0;
	if (c <= 'F')
		return (c - 'A')+10;
}

// blink out an error code
void error(Error error) {
	display.fillScreen(BLACK);
	switch (error) {
		case INIT_ERROR:
			printCenteredText("ERROR",                5, RED, 320, 0, 71);
			printCenteredText("SD card not found or", 2, RED, 320, 0, 117);
			printCenteredText("it couldn't be",       2, RED, 320, 0, 136);
			printCenteredText("initialized.",         2, RED, 320, 0, 155);
			break;
		case FILE_ERROR:
			printCenteredText("ERROR", 5, RED, 320, 0, 71);
			printCenteredText("The required file", 2, RED, 320, 0, 117);
			printCenteredText("couldn't be created", 2, RED, 320, 0, 136);
			break;
		case WRITE_ERROR:
			printCenteredText("ERROR", 5, RED, 320, 0, 71);
			printCenteredText("Couldn't write to", 2, RED, 320, 0, 117);
			printCenteredText("file. Card may have", 2, RED, 320, 0, 136);
			printCenteredText("been removed.", 2, RED, 320, 0, 155);
			break;
	}
	while (1) {
		delay(5000);
	}
}
String getDirection(double angle) {
	if (angle >= 337 && angle <= 360) return "N";
	if (angle >= 0   && angle < 22)   return "N";
	if (angle >= 67  && angle < 112)  return "E";
	if (angle >= 157 && angle < 202)  return "S";
	if (angle >= 247 && angle < 292)  return "W";
	if (angle >= 22  && angle < 67)   return "NE";
	if (angle >= 112 && angle < 157)  return "SE";
	if (angle >= 202 && angle < 247)  return "SW";
	if (angle >= 292 && angle < 337)  return "NW";
}

void setup() {
	Serial.begin(115200);
	display.reset();
	display.begin(display.readID());
	display.setRotation(1);
	display.fillScreen(BLACK);
	display.drawBitmap(96, 40, volvo_2_top, 128, 49, GREY);
	display.drawBitmap(96, 90, volvo_2_middle, 128, 32, BLUE);
	display.drawBitmap(96, 123, volvo_2_bottom, 128, 47, GREY);
	printCenteredText("Initializing...", 2, WHITE, 320, 0, 188);
	sensors.begin();
	ts.begin();
	pinMode(LEDPIN, OUTPUT);

	screens[0] = new SummaryScreen();
	screens[1] = new SpeedScreen();
	screens[2] = new DirectionScreen();
	screens[3] = new TemperatureScreen();
	screens[4] = new AltitudeScreen();
	screens[5] = new SatellitesScreen();
	screens[6] = new LogsAndPointsScreen();
	screens[7] = new SettingsScreen();
	screens[8] = new BlankScreen();

	// make sure that the default chip select pin is set to
	// output, even if you don't use it:
	pinMode(CHIPSELECT, OUTPUT);
	pinMode(DISPLAYBUTTON, OUTPUT);
	// see if the card is present and can be initialized:
	if (!SD.begin(CHIPSELECT, 11, 12, 13)) {
		error(INIT_ERROR);
	}
	printCenteredText("Creating file...", 2, WHITE, 320, 0, 188);

	char filename[15];
	strcpy(filename, "LOG0000.csv");
	for (uint8_t i = 0; i < 10000; i++) {
		filename[3] = '0' + (i/1000)%10;
		filename[4] = '0' + (i/100)%10;
		filename[5] = '0' + (i/10)%10;
		filename[6] = '0' + i%10;

		// create if does not exist, do not open existing, write, sync after write
		if (! SD.exists(filename)) {
			Serial.print(filename);
			Serial.println(" doesn't exist");
			break;
		}
		logs = i+1;
	}

	logfile = SD.open(filename, FILE_WRITE);
	if (!logfile) error(FILE_ERROR);

	printCenteredText("Starting GPS...", 2, WHITE, 320, 0, 188);
	GPS.begin(9600);
	// uncomment this line to turn on RMC (recommended minimum) and GGA (fix data) including altitude
	GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_ALLDATA);
	// uncomment this line to turn on only the "minimum recommended" data
	//GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCONLY);
	// For logging data, we don't suggest using anything but either RMC only or RMC+GGA
	// to keep the log files at a reasonable size
	// Set the update rate
	GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ); // 100 millihertz (once every 10 seconds), 1Hz or 5Hz update rate
	// Turn off updates on antenna status, if the firmware permits it
	GPS.sendCommand(PGCMD_NOANTENNA);

	GPS.sendCommand(PMTK_ENABLE_SBAS);
	GPS.sendCommand(PMTK_ENABLE_WAAS);

	// the nice thing about this code is you can have a timer0 interrupt go off
	// every 1 millisecond, and read data from the GPS for you. that makes the
	// loop code a heck of a lot easier!
	useInterrupt(true);
	display.fillScreen(BLACK);
	printTopBar();
	newGpsStatus.refresh = true;
	screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
	newGpsStatus.refresh = false;

}
// Interrupt is called once a millisecond, looks for any new GPS data, and stores it
SIGNAL(TIMER0_COMPA_vect) {
	char c = GPS.read();
	// if you want to debug, this is a good time to do it!
#ifdef UDR0
	if (GPSECHO)
		if (c) UDR0 = c;
	// writing direct to UDR0 is much much faster than Serial.print
	// but only one character can be written at a time.
#endif
}

void useInterrupt(boolean v) {
	if (v) {
		// Timer0 is already used for millis() - we'll just interrupt somewhere
		// in the middle and call the "Compare A" function above
		OCR0A = 0xAF;
		TIMSK0 |= _BV(OCIE0A);
		usingInterrupt = true;
	} else {
		// do not call the interrupt function COMPA anymore
		TIMSK0 &= ~_BV(OCIE0A);
		usingInterrupt = false;
	}
}

bool firstIteration = true;
void printTopBar() {
	display.setTextColor(BLACK);
	display.setTextSize(2);
	if (firstIteration)
	{
		display.setCursor(3,3);
		display.fillRect(0, 0, 320, 20, GREEN);
		display.print(newDate.getDate());
		display.print("         ");
		display.print(newDate.getTime());
		firstIteration = false;
	} else {
		display.setTextSize(2);
		if (oldDate.day != newDate.day)
		{
			display.fillRect(3,3,10,14, GREEN);
			display.fillRect(15,3,10,14, GREEN);
			display.setCursor(3,3);
			if (GPS.day < 10){
				display.print("0");
				display.print(GPS.day);
			} else {
				display.print(GPS.day);
			}
		}

		if (oldDate.mth != newDate.mth)
		{
			display.fillRect(39,3,10,14, GREEN);
			display.fillRect(51,3,10,14, GREEN);
			display.setCursor(39,3);
			if (GPS.month < 10){
				display.print("0");
				display.print(GPS.month);
			} else {
				display.print(GPS.month);
			}
		}

		if (oldDate.yr != newDate.yr)
		{
			display.fillRect(99,3,10,14, GREEN);
			display.fillRect(111,3,10,14, GREEN);
			display.setCursor(99,3);
			if (GPS.year < 10){
				display.print("0");
				display.print(GPS.year, DEC);
			} else {
				display.print(GPS.year, DEC);
			}
		}

		if (oldDate.hr != newDate.hr)
		{
			display.fillRect(219,3,10,14, GREEN);
			display.fillRect(231,3,10,14, GREEN);
			display.setCursor(219,3);
			if (GPS.hour < 10){
				display.print("0");
				display.print(GPS.hour);
			} else {
				display.print(GPS.hour);
			}
		}

		if (oldDate.min != newDate.min)
		{
			display.fillRect(255,3,10,14, GREEN);
			display.fillRect(267,3,10,14, GREEN);
			display.setCursor(255,3);
			if (GPS.minute < 10){
				display.print("0");
				display.print(GPS.minute);
			} else {
				display.print(GPS.minute);
			}
		}

		if (oldDate.sec != newDate.sec || oldDate.mil != newDate.mil)
		{
			display.fillRect(291,3,10,14, GREEN);
			display.fillRect(303,3,10,14, GREEN);
			display.setCursor(291,3);
      int addSecs = GPS.seconds;
      if (GPS.milliseconds >= 500) addSecs++;
			if (addSecs < 10){
				display.print("0");
				display.print(addSecs);
			} else {
				display.print(addSecs);
			}
		}
	}
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

int oldMaxSpeed = 999;

void drawCircleLine(double degree, double circleX, double circleY, double rBegin, double rEnd, int color) {
	display.drawLine((circleX + (rBegin * cos(degree * 1000.0/57296.0))),
	                 (circleY + (rBegin * sin(degree * 1000.0/57296.0))),
	                 (circleX + (rEnd   * cos(degree * 1000.0/57296.0))),
	                 (circleY + (rEnd   * sin(degree * 1000.0/57296.0))),
	                 color);
}

void logPointToFile(DeviceAddress tempSensor) {
	// Print the current time.
	if (logfile.print(newDate.getISOTimestamp()) == 0) error(WRITE_ERROR);
	if (logfile.print(';') == 0)                       error(WRITE_ERROR);

	// Print the latitude
	if (logfile.print(GPS.latitudeDegrees,14) == 0)    error(WRITE_ERROR);
	if (logfile.print(';') == 0)                       error(WRITE_ERROR);

	// Print the longitude
	if (logfile.print(GPS.longitudeDegrees,14) == 0)   error(WRITE_ERROR);
	if (logfile.print(';') == 0)                       error(WRITE_ERROR);

	// Print the altitude
	if (logfile.print(GPS.altitude,14) == 0)           error(WRITE_ERROR);
	if (logfile.print(';') == 0)                       error(WRITE_ERROR);

	// Print the temperature.
	if (sensors.getAddress(tempDeviceAddress, 0)) {
		double temp = sensors.getTempC(tempSensor);
		if (temp < minTemp) minTemp = temp;
		if (temp > maxTemp) maxTemp = temp;
		if (logfile.println(temp) == 0) error(WRITE_ERROR);
	} else {
		if (logfile.println("NULL") == 0) error(WRITE_ERROR);
	}
	logfile.flush();
}

double distanceBetweenPoints(double lat1, double lat2, double lon1, double lon2) {
	int R = 6371; // km
	double dLat = (lat2-lat1)*PI/180;
	double dLon = (lon2-lon1)*PI/180;
	lat1 = lat1*PI/180;
	lat2 = lat2*PI/180;

	double a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1) * cos(lat2);
	double c = 2 * atan2(sqrt(a), sqrt(1-a));
	double d = R * c;

	return d;
}

bool hasBeenPressed = false;
double oldLat = NULL, oldLon = NULL;

bool tappedSpeed   (int x, int y) { return 118 < x && x <= 215 && 107 >= y && y > 0;   }
bool tappedDir     (int x, int y) { return 118 < x && x <= 215 && 213 >= y && y > 107; }
bool tappedTemp    (int x, int y) { return 118 < x && x <= 215 && 320 >= y && y > 213; }

bool tappedAlt     (int x, int y) { return 20 < x && x <= 118 && 107 >= y && y >= 0;   }
bool tappedSats    (int x, int y) { return 20 < x && x <= 118 && 213 >= y && y > 107;  }
bool tappedLogs    (int x, int y) { return 20 < x && x <= 118 && 320 >= y && y > 213;  }

bool tappedTime    (int x, int y) { return 118 <= x && x <= 240 && 0 <= y && y <= 320; }
bool tappedLocation(int x, int y) { return 0 <= x && x <= 20 && 0 <= y && y <= 320;    }

void loop() {
	if (ts.touched() && !hasBeenPressed) {
		hasBeenPressed = true;

		TS_Point p = ts.getPoint();

		if (currentScreen != 0)
		{
			currentScreen = 0;
		} else {
			if (tappedSpeed(p.x, p.y)) {
				currentScreen = 1;
			} else if (tappedDir(p.x, p.y)) {
				currentScreen = 2;
			} else if (tappedTemp(p.x, p.y)) {
				currentScreen = 3;
			} else if (tappedAlt(p.x, p.y)) {
				currentScreen = 4;
			} else if (tappedSats(p.x, p.y)) {
				currentScreen = 5;
			} else if (tappedLogs(p.x, p.y)) {
				currentScreen = 6;
			} else if (tappedTime(p.x, p.y)) {
				currentScreen = 7;
			} else if (tappedLocation(p.x, p.y)) {
				currentScreen = 8;
			} else {
				return;
			}
		}
		display.fillRect(0,20,320,240, BLACK);
		newGpsStatus.refresh = true;
		screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
		newGpsStatus.refresh = false;
	} else if (!ts.touched()) {
		hasBeenPressed = false;
	}

	// if a sentence is received, we can check the checksum, parse it...
	if (GPS.newNMEAreceived()) {
		// a tricky thing here is if we print the NMEA sentence, or data
		// we end up not listening and catching other sentences!
		// so be very wary if using OUTPUT_ALLDATA and trying to print out data

		// Don't call lastNMEA more than once between parse calls!  Calling lastNMEA
		// will clear the received flag and can cause very subtle race conditions if
		// new data comes in before parse is called again.

		char *stringptr = GPS.lastNMEA();

		if (!GPS.parse(stringptr))   // this also sets the newNMEAreceived() flag to false
			return;  // we can fail to parse a sentence in which case we should just wait for another

		// Sentence parsed! Display updated data!
		newDate.updateDate(GPS.year, GPS.month, GPS.day, GPS.hour, GPS.minute, GPS.seconds, GPS.milliseconds);
		printTopBar();

		// Read temperature from the sensor.
		sensors.requestTemperatures();
		double temp;
		if (sensors.getAddress(tempDeviceAddress, 0)) {
			newGpsStatus.temperature = sensors.getTempC(tempDeviceAddress);
			currTemp = temp;
			//if (temp < minTemp) minTemp = temp;
			//if (temp > maxTemp) maxTemp = temp;
		} else {
			currTemp = -3.4028235E+38;
		}

		// Update the max speed.
		if (newGpsStatus.speed > newGpsStatus.maxSpeed)
			newGpsStatus.maxSpeed = newGpsStatus.speed;

		// Calculate the distance between the old and new points.
		if (oldGpsStatus.lat != NULL && oldGpsStatus.lon != NULL) {
			newGpsStatus.distance += distanceBetweenPoints(oldGpsStatus.lat,
			                                               newGpsStatus.lat,
			                                               oldGpsStatus.lon,
			                                               newGpsStatus.lon);

			// This will do for now.
			newGpsStatus.avgSpeed = newGpsStatus.distance/trkpts*60*60;
		}

		bool shouldLog = (!(LOG_FIXONLY && !GPS.fix)) && strstr(stringptr, "RMC");
		// Rad. lets log it! Only if the GPS has aquired a fix!
		if (shouldLog){
			newGpsStatus.points++;
		}
		// Display the selected screen.
		screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);

		// Do not refresh the elements that do not have to be refreshed again.
		newGpsStatus.refresh = false;

		if (shouldLog){
			logPointToFile(tempDeviceAddress);
		}

		oldGpsStatus = newGpsStatus;
		oldDate      = newDate;
	}
}