// Volvo Car GPS with Touch Screen UI
#include <SPI.h>
#include <Adafruit_GPS.h>
#include <SoftwareSerial.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_TFTLCD.h> // Hardware-specific library
#include <avr/sleep.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_FT6206.h>
#include <math.h>

// Pins
#define LCD_CS    A3 // Chip Select goes to Analog 3
#define LCD_CD    A2 // Command/Data goes to Analog 2
#define LCD_WR    A1 // LCD Write goes to Analog 1
#define LCD_RD    A0 // LCD Read goes to Analog 0
#define LCD_RESET A4 // Can alternately just connect to Arduino's reset pin

#define ONE_WIRE_BUS  31
#define BACKLIGHT_PIN 44
#define CHIPSELECT    10
#define LEDPIN        13
#define DISPLAYBUTTON 40

// Options
#define GPSECHO               false
#define LOG_FIXONLY           true
#define TEMPERATURE_PRECISION 11
#define MAX_SPEED 90

// The size of the screen
#define SCREEN_WIDTH  320
#define SCREEN_HEIGHT 240

// Colors
#define	BLACK     0x0000
#define	BLUE      0x001F
#define	VOLVOBLUE 0x001E
#define	RED       0xF800
#define	GREEN     0xDFEF
#define CYAN      0x07FF
#define MAGENTA   0xF81F
#define YELLOW    0xFFE0
#define WHITE     0xFFFF
#define GREY      0xE71C

enum Error {
	INIT_ERROR,
	FILE_ERROR,
	WRITE_ERROR
};

Adafruit_GPS      GPS(&Serial1);                                      // Library driver for the GPS.
Adafruit_TFTLCD   display(LCD_CS, LCD_CD, LCD_WR, LCD_RD, LCD_RESET); // Library driver for the TFT LCD.
Adafruit_FT6206   ts = Adafruit_FT6206();                             // Library driver for the touch.
OneWire           oneWire(ONE_WIRE_BUS);                              // Library for the digital temperature sensor.
DallasTemperature sensors(&oneWire);                                  // Library for the digital temperature sensor.
DeviceAddress     tempDeviceAddress;                                  // Library for the digital temperature sensor.
File              logfile;                                            // The file to write to.

int          currentScreen = 0;         // The current screen that is displayed.

bool         wasPressed = false,        // Tells if the screen has already been pressed.
             gotFix = false,            // Tells if the GPS has gotten a fix since start.
             usingInterrupt = false;    // Tells if we should use interrupts for parsing NMEA data.

unsigned int logs = 0;                  // The number of the log on the SD card currently written to.
unsigned int backgroundColor = BLACK;
unsigned int textColor = GREEN;


const unsigned char  PROGMEM volvo_2_top [] = {
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11111111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00000001, B11111111, B11110000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11000000, B00000000, B00001111, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B11111111, B11111000, B00000000, B00000011, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000000, B11111111, B00000000, B01111111, B11111111, B11111111, B11111111, B00000000, B00000001, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000011, B11111000, B00000000, B01111111, B11111111, B11111111, B11111111, B11000000, B00000000, B01111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00001111, B11000000, B00000000, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00111111, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11111100, B00000000, B00001111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B11111100, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11111110, B00000000, B00000111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000001, B11110000, B00000000, B00000111, B11111111, B11111111, B11111111, B11111111, B11111111, B10000000, B00110011, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000111, B11000000, B00000000, B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11100000, B01111001, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00001111, B10000000, B00000000, B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000, B11111110, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00011110, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111001, B11111111, B01111111, B11111100,
	B00000000, B00000000, B00000000, B01111100, B00000000, B00000000, B11111111, B00000000, B00000000, B11111111, B11111111, B11111111, B11110011, B11111111, B00111111, B11111100,
	B00000000, B00000000, B00000000, B11110000, B00000000, B00000011, B11100000, B00000000, B00000000, B00000111, B11111111, B11111111, B11100111, B11111111, B10011111, B11111100,
	B00000000, B00000000, B00000001, B11100000, B00000000, B00000111, B00000001, B11000000, B00000000, B00000000, B11111111, B11111111, B11001111, B11111111, B11001111, B11111100,
	B00000000, B00000000, B00000011, B11000000, B00000000, B00001100, B00011111, B11111100, B00000000, B00000000, B00111111, B11111111, B10011111, B11111111, B11100111, B11111100,
	B00000000, B00000000, B00000111, B10000000, B00000000, B00010000, B11111111, B11111111, B10000000, B00000000, B00000111, B11111111, B00111111, B11111111, B11110011, B11111100,
	B00000000, B00000000, B00001111, B00000000, B00000000, B00000011, B11111111, B11111111, B11100000, B00000000, B00000001, B11111110, B01111111, B11111111, B11111011, B11111100,
	B00000000, B00000000, B00011110, B00000000, B00000000, B00011111, B11111111, B11111111, B11110000, B00000000, B00000000, B11111110, B11111111, B11111111, B11111101, B11111100,
	B00000000, B00000000, B00111100, B00000000, B00000000, B00111111, B11111111, B11111111, B11111000, B00000000, B00000000, B00111111, B11111111, B11111111, B11111100, B11111100,
	B00000000, B00000000, B01111000, B00000000, B00000000, B11111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00011111, B11111111, B11111111, B11111110, B11111100,
	B00000000, B00000000, B11110000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000111, B11111111, B11111111, B11111100, B01111100,
	B00000000, B00000000, B11100000, B00000000, B00000111, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00000011, B11111111, B11111111, B11111000, B00111100,
	B00000000, B00000001, B11000000, B00000000, B00001111, B11111111, B11111111, B11100000, B00000111, B11111110, B00000000, B00000001, B11111111, B11111111, B11110000, B00111100,
	B00000000, B00000011, B10000000, B00000000, B00111111, B11111111, B11111100, B00000000, B00000000, B00111111, B10000000, B00000000, B11111111, B11111111, B11100000, B00011100,
	B00000000, B00000111, B10000000, B00000000, B01111111, B11111111, B11100000, B00000000, B00000000, B00000111, B11100000, B00000000, B01111111, B11111111, B11100000, B00001100,
	B00000000, B00000111, B00000000, B00000000, B11111111, B11111111, B10000000, B00000000, B00000000, B00000001, B11111000, B00000000, B00111111, B11111111, B11100000, B00001100,
	B00000000, B00001110, B00000000, B00000001, B11111111, B11111110, B00000000, B00000000, B00000000, B00000000, B01111100, B00000000, B00011111, B11111111, B11110000, B00000100,
	B00000000, B00001110, B00000000, B00000011, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00011110, B00000000, B00001111, B11111111, B11110000, B00000100,
	B00000000, B00011100, B00000000, B00000111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000111, B10000000, B00000111, B11111111, B11111000, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11000000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11100000, B00000001, B11111111, B11111100, B00000000,
	B00000000, B01110000, B00000000, B00011111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11110000, B00000001, B11111111, B11111110, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01111000, B00000000, B11111111, B11111110, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00111100, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011110, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11000000, B00000000, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001111, B00000000, B00111111, B11111111, B00000000,
	B00000001, B11000000, B00000000, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B00000000, B00111111, B11111111, B10000000,
	B00000001, B10000000, B00000001, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B10000000, B00011111, B11111111, B10000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00011111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00001111, B11111111, B11000000,
	B00000011, B00000000, B00000011, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00001111, B11111111, B11000000,
	B00000111, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000111, B11111111, B11100000,
	B00000111, B00000000, B00000111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000111, B11111111, B11100000,
	B00000111, B00000000, B00001111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000011, B11111111, B11100000,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100
};
const unsigned char  PROGMEM volvo_2_middle [] = {
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B10000000, B00000001, B11000000, B00001111, B10000000, B11111110, B00000000, B00001110, B00000000, B00000111, B00000000, B00111110, B00000011, B11111111, B11111110,
	B11111111, B10000000, B00000001, B11000000, B00001100, B00000000, B00011110, B00000000, B00001110, B00000000, B00000111, B00000000, B00110000, B00000000, B01111111, B11111110,
	B11111111, B11110000, B00000111, B11110000, B01111000, B00001000, B00001111, B11000000, B00011111, B11000000, B00011111, B11000001, B11100000, B00100000, B00111111, B11111111,
	B11111111, B11111000, B00000111, B11110000, B01110000, B00011110, B00000111, B11000000, B01111111, B11100000, B00011111, B11000001, B11000000, B11111000, B00011111, B11111111,
	B11111111, B11111100, B00000011, B11110000, B11100000, B00111110, B00000011, B11000000, B01111111, B11110000, B00001111, B11000011, B10000000, B11111000, B00001111, B11111111,
	B11111111, B11111100, B00000011, B11100000, B11100000, B00111111, B00000011, B11000000, B01111111, B11110000, B00001111, B10000111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111110, B00000001, B11100001, B11100000, B00111111, B00000011, B11000000, B01111111, B11111000, B00000111, B10000111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111110, B00000001, B11000011, B11100000, B00111111, B00000011, B11000000, B01111111, B10011000, B00000111, B00001111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111111, B00000000, B11000011, B11100000, B00111111, B00000011, B11000000, B01111111, B00011100, B00000011, B00001111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111111, B00000000, B00000111, B11100000, B00111110, B00000011, B11000000, B01111111, B00011100, B00000000, B00011111, B10000000, B11111000, B00001111, B11111111,
	B01111111, B11111111, B10000000, B00000111, B11110000, B00011110, B00000111, B11000000, B01111110, B00011110, B00000000, B00011111, B11000000, B01111000, B00011111, B11111111,
	B01111111, B11111111, B11000000, B00001111, B11111000, B00001100, B00001111, B11000000, B00111000, B00011110, B00000000, B00111111, B11100000, B00110000, B00111111, B11111110,
	B01111111, B11111111, B11000000, B00001111, B11111100, B00000000, B00011110, B00000000, B00000000, B00011111, B00000000, B00111111, B11110000, B00000000, B01111111, B11111110,
	B01111111, B11111111, B11100000, B00011111, B11111111, B00000000, B01111110, B00000000, B00000000, B00011111, B10000000, B01111111, B11111100, B00000001, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100
};
const unsigned char  PROGMEM volvo_2_bottom [] = {
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00000111, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000111, B11111111, B11100000,
	B00000011, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00001111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00001111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00011111, B11111111, B11000000,
	B00000001, B10000000, B00000001, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B10000000, B00011111, B11111111, B10000000,
	B00000001, B11000000, B00000001, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B00000000, B00111111, B11111111, B10000000,
	B00000001, B11000000, B00000000, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001111, B00000000, B00111111, B11111111, B10000000,
	B00000000, B11100000, B00000000, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001110, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011100, B00000000, B01111111, B11111111, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00111000, B00000000, B11111111, B11111110, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000001, B11111111, B11111110, B00000000,
	B00000000, B00111000, B00000000, B00011111, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11000000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00011100, B00000000, B00000111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000111, B10000000, B00000111, B11111111, B11111000, B00000000,
	B00000000, B00011100, B00000000, B00000011, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00011111, B00000000, B00001111, B11111111, B11111000, B00000000,
	B00000000, B00001110, B00000000, B00000001, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00111110, B00000000, B00011111, B11111111, B11110000, B00000000,
	B00000000, B00000111, B00000000, B00000000, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00111111, B11111111, B11100000, B00000000,
	B00000000, B00000111, B00000000, B00000000, B01111111, B11111111, B11100000, B00000000, B00000000, B00000011, B11100000, B00000000, B01111111, B11111111, B11100000, B00000000,
	B00000000, B00000011, B10000000, B00000000, B00111111, B11111111, B11111100, B00000000, B00000000, B00011111, B11000000, B00000000, B11111111, B11111111, B11000000, B00000000,
	B00000000, B00000001, B11000000, B00000000, B00011111, B11111111, B11111111, B10000000, B00000001, B11111110, B00000000, B00000001, B11111111, B11111111, B10000000, B00000000,
	B00000000, B00000001, B11100000, B00000000, B00001111, B11111111, B11111111, B11111111, B11111111, B11111000, B00000000, B00000111, B11111111, B11111111, B00000000, B00000000,
	B00000000, B00000000, B11110000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11100000, B00000000, B00001111, B11111111, B11111111, B00000000, B00000000,
	B00000000, B00000000, B01110000, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11000000, B00000000, B00011111, B11111111, B11111110, B00000000, B00000000,
	B00000000, B00000000, B00111000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B10000000, B00000000, B01111111, B11111111, B11111100, B00000000, B00000000,
	B00000000, B00000000, B00011100, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B00000000, B00000001, B11111111, B11111111, B11111000, B00000000, B00000000,
	B00000000, B00000000, B00001110, B00000000, B00000000, B00000111, B11111111, B11111111, B11111110, B00000000, B00000011, B11111111, B11111111, B11110000, B00000000, B00000000,
	B00000000, B00000000, B00000111, B00000000, B00000000, B00000000, B11111111, B11111111, B11111000, B00000000, B00011111, B11111111, B11111111, B11100000, B00000000, B00000000,
	B00000000, B00000000, B00000011, B10000000, B00000000, B00000000, B00011111, B11111111, B11100000, B00000000, B01111111, B11111111, B11111111, B11000000, B00000000, B00000000,
	B00000000, B00000000, B00000001, B11100000, B00000000, B00000000, B00000000, B11111111, B00000000, B00000011, B11111111, B11111111, B11111111, B10000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B01111000, B00000000, B00000000, B00000011, B10000000, B00000111, B11111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00111110, B00000000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B11111111, B11111100, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00001111, B00000000, B00000000, B00000000, B00001111, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000111, B11000000, B00000000, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11100000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000011, B11100000, B00000000, B00000000, B00000000, B00111111, B11111111, B11111111, B11111111, B10000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00000000, B00000000, B00000111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00111110, B00000000, B00000000, B00000000, B00000001, B11111111, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00001111, B11000000, B00000000, B00000000, B00000000, B01111111, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000111, B11110000, B00000000, B00000000, B00000000, B00111111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B11111110, B00000000, B00000000, B00000000, B01111111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00111111, B11100000, B00000000, B00000000, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111, B00000000, B00000011, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11111111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000
};



void printCenteredText(String text, int textSize, int color, int areaWidth, int offset, int y) {
	int x = (areaWidth-(text.length()*textSize*5+textSize*(text.length()-1)))/2+offset;
	display.setTextSize(textSize);
	display.setCursor(x,y);
	display.setTextColor(color);
	display.fillRect(offset+1,y,areaWidth-2,textSize*8, BLACK);
	display.print(text);
}

struct DisplayDate {
	int sec, min, hr, day, mth, yr, mil;

	DisplayDate(int yr, int mth, int day, int hr, int min, int sec, int mil) {
		this->yr  = yr;
		this->mth = mth;
		this->day = day;
		this->hr  = hr;
		this->min = min;
		this->sec = sec;
		this->mil = mil;
	}

	void updateDate(int yr, int mth, int day, int hr, int min, int sec, int mil) {
		this->yr  = yr;
		this->mth = mth;
		this->day = day;
		this->hr  = hr;
		this->min = min;
		this->sec = sec;
		this->mil = mil;
	}

	String getDate() {
		String date;
		this->day < 10 ? date.concat("0"):false;
		date.concat(String(day));
		date.concat(".");
		this->mth < 10 ? date.concat("0"):false;
		date.concat(String(mth));
		date.concat(".");
		date.concat("20");
		date.concat(String(yr));
		return date;
	}

	String getTime() {
		String date;
		this->hr < 10 ? date.concat("0"):false;
		date.concat(String(hr));
		date.concat(":");
		this->min < 10 ? date.concat("0"):false;
		date.concat(String(min));
		date.concat(":");
		this->sec < 10 ? date.concat("0"):false;
		date.concat(String(sec));
		return date;
	}

	String getISOTimestamp() {
		String isoDate;
		isoDate.concat("20");
		if (this->yr < 10) isoDate.concat('0');
		isoDate.concat(this->yr);
		isoDate += "-";

		if (this->mth < 10) isoDate.concat('0');
		isoDate.concat(this->mth);
		isoDate.concat('-');

		if (this->day < 10) isoDate.concat('0');
		isoDate.concat(this->day);

		isoDate.concat('T');

		if (this->hr < 10) isoDate.concat('0');
		isoDate.concat(this->hr);
		isoDate.concat(':');

		if (this->min < 10) isoDate.concat('0');
		isoDate.concat(this->min);
		isoDate.concat(':');

		if (this->sec < 10) isoDate.concat('0');
		isoDate.concat(this->sec);
		isoDate.concat('.');

		isoDate.concat(this->mil);
		isoDate.concat('Z');
		return isoDate;
	}
};
DisplayDate newDate(GPS.year, GPS.month, GPS.day, GPS.hour, GPS.minute, GPS.seconds, GPS.milliseconds);
DisplayDate oldDate(0,0,0,0,0,0,0);

struct GPS_Status
{
	DisplayDate date();

	double speed,
	       angle,
	       temperature,
	       minTemp,
	       maxTemp,
	       altitude,
	       acceleration,
	       hdop,
	       distance,
	       avgSpeed,
	       maxSpeed,
	       lat,
	       lon;

	bool refresh;

	int satellites,
	    fix,
	    points;


	GPS_Status() {
		this->speed = NULL;
		this->angle = NULL;
		this->temperature = NULL;
		this->altitude = NULL;
		this->acceleration = NULL;
		this->hdop = NULL;
		this->points = NULL;
		this->distance = NULL;
		this->avgSpeed = NULL;
		this->maxSpeed = NULL;
		this->lat = NULL;
		this->lon = NULL;
	}

	GPS_Status(double speed, double angle, double altitude, double hdop, double lat, double lon, int satellites, int fix) {
		this->speed        = speed;
		this->angle        = angle;
		this->altitude     = altitude;
		this->hdop         = hdop;
		this->lat          = lat;
		this->lon          = lon;
        this->satellites   = satellites;
        this->fix          = fix;
	}
	void updateStatus(double speed, double angle, double altitude, double hdop, double lat, double lon, int satellites, int fix) {
		this->speed        = speed;
		this->angle        = angle;
		this->altitude     = altitude;
		this->hdop         = hdop;
		this->lat          = lat;
		this->lon          = lon;
        this->satellites   = satellites;
        this->fix          = fix;
	}
};
GPS_Status newGpsStatus;
GPS_Status oldGpsStatus;

class Screen {
	public:
	virtual void displayScreen(GPS_Status* data, GPS_Status* oldData);
	virtual bool wasTapped(int x, int y);
};
Screen*           screens[9];

class SummaryScreen: public Screen {

	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displaySpeed() {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, textColor, 107, 0, 30);
		}
		double acceleration;
		if (newStatus->speed != oldStatus->speed || newStatus->refresh) {
			if (newStatus->speed < 10)                                   printCenteredText(String(newStatus->speed, 2), 3, textColor, 107, 0, 64);
			else if (newStatus->speed >= 10 && newStatus->speed < 100)   printCenteredText(String(newStatus->speed, 2), 3, textColor, 107, 0, 64);
			else if (newStatus->speed >= 100 && newStatus->speed < 1000) printCenteredText(String(newStatus->speed, 1), 3, textColor, 107, 0, 64);
			else if (newStatus->speed >= 1000)                           printCenteredText(String(newStatus->speed, 0), 3, textColor, 107, 0, 64);
			printCenteredText(String(newStatus->acceleration, 2), 2, textColor, 107, 0, 95);
		}
	}

	void displayDirection() {

		if (newStatus->refresh) {
			printCenteredText("DIRECTION", 1, textColor, 107, 107, 30);
		}

		String dir = getDirection(newStatus->angle);

		if (getDirection(oldStatus->angle) != dir || newStatus->refresh) {
			printCenteredText(dir, 3, textColor, 107, 107, 64);
		}

		if (oldStatus->angle != newStatus->angle || newStatus->refresh) {
			printCenteredText(String(newStatus->angle), 2, textColor, 107, 107, 95);
		}
	}

	void displayTemperature() {
		if (newStatus->refresh) {
			printCenteredText("TEMPERATURE", 1, textColor, 107, 214, 30);
		}

		if (oldStatus->temperature != newStatus->temperature || newStatus->refresh) {

			if (newStatus->temperature != NULL) {
				if      (newStatus->temperature <= -100 || newStatus->temperature >= 1000)
					printCenteredText(String(newStatus->temperature, 0), 3, textColor, 107, 214, 64);
				else if ((newStatus->temperature <= -10 && newStatus->temperature > -100) ||
				         (newStatus->temperature >= 100 && newStatus->temperature < 1000))
					printCenteredText(String(newStatus->temperature, 1), 3, textColor, 107, 214, 64);
				else if (-10 < newStatus->temperature && newStatus->temperature < 100)
					printCenteredText(String(newStatus->temperature, 2), 3, textColor, 107, 214, 64);
			} else {
				printCenteredText("DISC", 3, textColor, 107, 214, 64);
			}
		}
	}

	void displayAltitude() {
		if (newStatus->refresh) {
			display.setCursor(30,128);
			display.setTextSize(1);
			display.print("ALTITUDE");
		}
		if (oldStatus->altitude != newStatus->altitude || newStatus->refresh) {
			if      (newStatus->altitude <= -100 || newStatus->altitude >= 1000)   printCenteredText(String(newStatus->altitude, 0), 3, textColor, 107, 214, 162);
			else if ((newStatus->altitude <= -10 && newStatus->altitude > -100) ||
			         (newStatus->altitude >= 100 && newStatus->altitude < 1000))   printCenteredText(String(newStatus->altitude, 1), 3, textColor, 107, 0, 162);
			else if (-10 < newStatus->altitude && newStatus->altitude < 100)       printCenteredText(String(newStatus->altitude, 2), 3, textColor, 107, 0, 162);
		}
	}

	void displaySatellites() {
		if (newStatus->refresh) {
			display.setCursor(131,128);
			printCenteredText("SATELLITES", 1, textColor, 107, 107, 128);
		}

		if (oldStatus->satellites != newStatus->satellites || newStatus->refresh) {
			printCenteredText(String(newStatus->satellites), 3, textColor, 107, 107, 162);
		}

		if (oldStatus->hdop != newStatus->hdop || newStatus->refresh) {
			printCenteredText(String(newStatus->hdop, 2), 2, textColor, 107, 107, 193);
		}
	}

	void displayLogsAndPoints(int logNumber) {
		if (newStatus->refresh) {
			printCenteredText("LOG", 1, textColor, 107, 214, 128);
			printCenteredText("POINTS", 1, textColor, 107, 214, 174);
			printCenteredText(String(logNumber), 2, textColor, 107, 214, 142);
		}

		if (oldStatus->points != newStatus->points || newStatus->refresh) {
			printCenteredText(String(newStatus->points), 2, textColor, 107, 214, 188);
		}
	}

	void displayOutlines() {
		if (newStatus->refresh) {
			display.drawLine(107,20, 107, 215, textColor);
			display.drawLine(213,20, 213, 215, textColor);
			display.drawLine(0, 118, 320, 118, textColor);
			display.drawLine(0, 215, 320, 215, textColor);
		}
	}

	void displayGPSStatus(int fix, double lat, double lon) {
		display.setTextColor(textColor);
		display.setTextSize(2);

		if (GPS.fix) {
			display.setCursor(35,221);
			gotFix = true;
			if (newGpsStatus.lat != oldGpsStatus.lat ||
				newGpsStatus.lon != oldGpsStatus.lon || newStatus->refresh) {

				display.fillRect(35,221,250,16, BLACK);
				display.print(GPS.lat);
				display.print(" ");
				GPS.lat == 'N' ? display.print(GPS.latitudeDegrees, 4) : display.print((-1)*GPS.latitudeDegrees, 4);
				display.print("   ");
				display.print(GPS.lon);
				display.print(" ");
				GPS.lon == 'W' ? display.print((-1)*GPS.longitudeDegrees, 4) : display.print(GPS.longitudeDegrees, 4);
			}
		}
		else {

			if (newGpsStatus.fix != oldGpsStatus.fix || newStatus->refresh)
			{
				display.fillRect(0,216,320,25, BLACK);
				if (!gotFix) {
					display.setCursor(41,221);
					display.setTextColor(BLUE);
					display.print("Acquiring Satellites");
				} else {
					display.setCursor(71,221);
					display.setTextColor(RED);
					display.print("Lost Satellites");
				}
			}

		}
	}
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData) {
		this->newStatus = data;
		this->oldStatus = oldData;

		displayOutlines();
		displaySpeed();
		displayDirection();
		displayTemperature();
		displayAltitude();
		displaySatellites();
		displayLogsAndPoints(logs);
		displayGPSStatus(GPS.fix, GPS.latitudeDegrees, GPS.longitudeDegrees);
	}

	bool wasTapped(int x, int y) {
		return false;
	}
};

class SpeedScreen: public Screen {
	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displayDataFieldOutlines() {
		display.drawLine(0,60,340,60,textColor);
		display.drawLine(0,100,80,100,textColor);
		display.drawLine(240,100,320,100,textColor);

		display.drawLine(80,20,80,100,textColor);
		display.drawLine(160,20,160,60,textColor);
		display.drawLine(240,20,240,100,textColor);
	}

	void displaySpeedometerOutlines() {
		display.drawCircle(160,240,150,textColor);
		for (int i = 1; i < MAX_SPEED; i++) {
			if (i % 10 == 0) {
				drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 135, textColor);
				continue;
			}

			if (i % 5 == 0) {
				drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 140, textColor);
				continue;
			}
			drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 145, textColor);
		}
	}

	void displaySpeedometerUpdated(float speed, float avgSpeed, float maxSpeed) {
		display.setTextSize(1);
		display.setTextColor(textColor);
		display.setCursor(40, 194);  display.print(10);
		display.setCursor(62, 157);  display.print(20);
		display.setCursor(92, 128);  display.print(30);
		display.setCursor(133, 113); display.print(40);
		display.setCursor(176, 113); display.print(50);
		display.setCursor(217, 128); display.print(60);
		display.setCursor(247, 157); display.print(70);
		display.setCursor(269, 194); display.print(80);
		//display.drawBitmap(96, 170, volvo, 128, 17, BLUE);

		float mappedSpeed = mapfloat(speed, 0.0, MAX_SPEED, 180.0, 360.0);
		if (mappedSpeed < 180) mappedSpeed = 180;

		drawCircleLine(mapfloat(oldStatus->speed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 0, 130, BLACK);
		drawCircleLine(mapfloat(newStatus->speed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 0, 130, RED);

		drawCircleLine(mapfloat(oldStatus->maxSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLACK);
		drawCircleLine(mapfloat(newStatus->maxSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, RED);

		drawCircleLine(mapfloat(oldStatus->avgSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLACK);
		drawCircleLine(mapfloat(newStatus->avgSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLUE);
	}

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, textColor, 80, 0, 24);
		}
		if (oldStatus->speed != newStatus->speed || newStatus->refresh) {
			printCenteredText(String(newStatus->speed,2), 2, textColor, 80, 0, 38);
		}
	}

	void displayAvgSpeed(float avgSpeed) {
		if (newStatus->refresh) {
			printCenteredText("AVG. SPEED", 1, textColor, 79, 80, 24);
		}
		if (oldStatus->avgSpeed != newStatus->avgSpeed || newStatus->refresh) {
			printCenteredText(String(newStatus->avgSpeed,2), 2, textColor, 80, 80, 38);
		}
	}

	void displayMaxSpeed(float maxSpeed) {
		if (newStatus->refresh) {
			printCenteredText("MAX SPEED", 1, textColor, 79, 160, 24);
		}
		if (oldStatus->maxSpeed != newStatus->maxSpeed || newStatus->refresh) {
			printCenteredText(String(newStatus->maxSpeed,2), 2, textColor, 80, 160, 38);
		}
	}

	void displayDistance(float distance) {
		if (newStatus->refresh) {
			printCenteredText("DISTANCE", 1, textColor, 80, 240, 24);
		}
		if (oldStatus->distance != newStatus->distance || newStatus->refresh) {
			printCenteredText(String(newStatus->distance, 2), 2, textColor, 80, 240, 38);
		}
	}

	void displayAltitude(float altitude) {
		if (newStatus->refresh) {
			printCenteredText("ALTITUDE", 1, textColor, 80, 0, 65);
		}
		if (oldStatus->altitude != newStatus->altitude || newStatus->refresh) {
			printCenteredText(String(newStatus->altitude,1), 2, textColor, 80, 0, 79);
		}
	}

	void displaySatellites(int satellites) {
		if (newStatus->refresh) {
			printCenteredText("SATELLITES", 1, textColor, 80, 240, 65);
		}
		if (oldStatus->satellites != newStatus->satellites || newStatus->refresh) {
			printCenteredText(String(newStatus->satellites), 2, textColor, 80, 240, 79);
		}
	}

	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData) {
		this->newStatus = newData;
		this->oldStatus = oldData;

		if (newStatus->refresh) {
			displayDataFieldOutlines();
		}
		displaySpeed(GPS.speed*1.852);
		displayAvgSpeed(newStatus->avgSpeed);
		displayMaxSpeed(newStatus->maxSpeed);
		displayDistance(newStatus->distance);
		displayAltitude(GPS.altitude);
		displaySatellites(GPS.satellites);
		if (newStatus->refresh) {
			displaySpeedometerOutlines();
		}
		displaySpeedometerUpdated(GPS.speed*1.852, newStatus->avgSpeed, newStatus->maxSpeed);

	}
	bool wasTapped(int x, int y) {
		return 118 < x && x <= 215 && 107 >= y && y > 0;
	}
};

class DirectionScreen: public Screen {
	float oldAngle, oldSpeed, oldAltitude;
	String oldDirection;
	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displayDataFieldOutlines() {
		// Upper Horizontal Lines
		display.drawLine(0,   60, 80, 60,  textColor);
		display.drawLine(240, 60, 320, 60, textColor);

		// Upper Vertical Lines
		display.drawLine(80,20,80,60,textColor);
		display.drawLine(240,20,240,60,textColor);

		// Lower Horizontal Lines
		display.drawLine(0,200,80,200,textColor);
		display.drawLine(240,200,320,200,textColor);

		// Lower Vertical Lines
		display.drawLine(80,200,80,240,textColor);
		display.drawLine(240,200,240,240,textColor);
	}

	void displayDirection(float angle) {
		if (newStatus->refresh) {
			printCenteredText("DIRECTION", 1, textColor, 80, 0,   24);
		}

		String dir = getDirection(angle);
		if (this->oldDirection != dir || newStatus->refresh) {
			printCenteredText(dir, 2, textColor, 80, 0, 38);
		}
		this->oldDirection = dir;
	}

	void displayAngle(float angle) {
		if (newStatus->refresh) {
			printCenteredText("ANGLE", 1, textColor, 80, 240, 24);
		}

		if (oldAngle != angle || newStatus->refresh) {
			printCenteredText(String(angle,1), 2, textColor, 80, 240, 38);
		}

		this->oldAngle = angle;
	}

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, textColor, 80, 0,   205);
		}

		if (oldSpeed != speed || newStatus->refresh) {
			printCenteredText(String(speed,2),    2, textColor, 80, 0,   219);
		}

		this->oldSpeed = speed;
	}

	void displayAltitude(float altitude) {
		if (newStatus->refresh) {
			printCenteredText("ALTITUDE",  1, textColor, 80, 240, 205);
		}

		if (oldAltitude != altitude || newStatus->refresh) {
			printCenteredText(String(altitude,2), 2, textColor, 80, 240, 219);
		}

		this->oldAltitude = altitude;
	}

	void displayCompassOutline() {
		display.drawCircle(160, 130, 100, textColor);

		display.drawLine  (259, 130, 250, 130, textColor);
		display.drawLine  (230, 200, 224, 194, textColor);
		display.drawLine  (160, 229, 160, 220, textColor);
		display.drawLine  (90,  200, 96,  194, textColor);
		display.drawLine  (61,  130, 70,  130, textColor);
		display.drawLine  (90,  60,  96,  66,  textColor);
		display.drawLine  (160, 31,  160, 40,  textColor);
		display.drawLine  (230, 60,  224, 66,  textColor);
		display.drawLine  (259, 130, 250, 130, textColor);
	}

	void displayCompassDirection(float angle) {

		if (oldAngle != angle || newStatus->refresh) {
			display.drawLine(160,
			                 130,
			                (160 + (90 * cos((oldAngle * 1000.0 / 57296.0)-(PI/2)))),
			                (130 + (90 * sin((oldAngle * 1000.0 / 57296.0)-(PI/2)))),
			                 BLACK);

			display.drawLine(160,
			                 130,
			                (160 + (90 * cos((angle * 1000.0 / 57296.0)-(PI/2)))),
			                (130 + (90 * sin((angle * 1000.0 / 57296.0)-(PI/2)))),
			                 RED);
		}
		oldAngle = angle;
	}

	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData) {
		this->newStatus = newData;
		this->oldStatus = oldData;

		if (newStatus->refresh) {
			displayDataFieldOutlines();
			displayCompassOutline();
		}
		// Not the best solution.
		displayCompassDirection(GPS.angle);
		displayDirection(GPS.angle);
		displayAngle(GPS.angle);
		displaySpeed(GPS.speed*1.852);
		displayAltitude(GPS.altitude);
	}
	bool wasTapped(int x, int y) {
		return 118 < x && x <= 215 && 213 >= y && y > 107;
	}
};

class TemperatureScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData) {

		newStatus = newData;
		oldStatus = oldData;

		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Temperature:\nWork in progress...");
		}
	}

	bool wasTapped(int x, int y) {
		return 118 < x && x <= 215 && 320 >= y && y > 213;
	}
};

class AltitudeScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Altitude:\nWork in progress...");
		}
	}
	bool wasTapped(int x, int y) {
		return 20 < x && x <= 118 && 107 >= y && y >= 0;
	}
};

class SatellitesScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;

    void displayCompassOutline() {
        display.drawCircle(160, 130, 100, textColor);
        drawCircleLine(0, 160, 130, 0, 100, GREEN);
        drawCircleLine(30, 160, 130, 0, 100, GREEN);
        drawCircleLine(60, 160, 130, 0, 100, GREEN);
        drawCircleLine(90, 160, 130, 0, 100, GREEN);
        drawCircleLine(120, 160, 130, 0, 100, GREEN);
        drawCircleLine(150, 160, 130, 0, 100, GREEN);
        drawCircleLine(180, 160, 130, 0, 100, GREEN);
        drawCircleLine(210, 160, 130, 0, 100, GREEN);
        drawCircleLine(240, 160, 130, 0, 100, GREEN);
        drawCircleLine(270, 160, 130, 0, 100, GREEN);
        drawCircleLine(300, 160, 130, 0, 100, GREEN);
        drawCircleLine(330, 160, 130, 0, 100, GREEN);
        display.drawCircle(160,130,50,GREEN);


    }
    void displaySatellitePoints() {
        
        for (int i = 0; i < GPS.satellitesInView; i++) {
            if (GPS.satelliteDetail[i].snr == NULL) {
                display.fillCircle((160 + (map(GPS.satelliteDetail[i].elevation, 0, 90, 100, 0) * cos((GPS.satelliteDetail[i].azimuth * 1000.0 / 57296.0)-(PI/2)))),
                                   (130 + (map(GPS.satelliteDetail[i].elevation, 0, 90, 100, 0) * sin((GPS.satelliteDetail[i].azimuth * 1000.0 / 57296.0)-(PI/2)))), 3, WHITE);

            } else {
              display.fillCircle((160 + (map(GPS.satelliteDetail[i].elevation, 0, 90, 100, 0) * cos((GPS.satelliteDetail[i].azimuth * 1000.0 / 57296.0)-(PI/2)))),
                                 (130 + (map(GPS.satelliteDetail[i].elevation, 0, 90, 100, 0) * sin((GPS.satelliteDetail[i].azimuth * 1000.0 / 57296.0)-(PI/2)))), 3, GREEN);

            }
        }
    }
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh)
		{
			displayCompassOutline();
		}
        displaySatellitePoints();

        display.setTextSize(2);
        display.setTextColor(textColor);
        display.setCursor(3,23);
        display.print(GPS.satellitesInView);


	}
	bool wasTapped(int x, int y) {
		return 20 < x && x <= 118 && 213 >= y && y > 107;
	}
};

class LogsAndPointsScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh)
		{
			display.drawLine(0,130,320,130,textColor);
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Time and position:\nWork in progress...");
		}
	}
	bool wasTapped(int x, int y) {
		return 20 < x && x <= 118 && 320 >= y && y > 213;
	}
};

class SettingsScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Settings:");

		}
	}
	bool wasTapped(int x, int y) {
		return 118 <= x && x <= 240 && 0 <= y && y <= 320;
	}
};

class BlankScreen: public Screen
{
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){}

	bool wasTapped(int x, int y) {
		return 0 <= x && x <= 20 && 0 <= y && y <= 320;
	}
};

void useInterrupt(boolean);

uint8_t parseHex(char c) {
	if (c < '0')
		return 0;
	if (c <= '9')
		return c - '0';
	if (c < 'A')
		return 0;
	if (c <= 'F')
		return (c - 'A')+10;
}

// blink out an error code
void error(Error error) {
	display.fillScreen(BLACK);
	switch (error) {
		case INIT_ERROR:
			printCenteredText("ERROR",                5, RED, 320, 0, 71);
			printCenteredText("SD card not found or", 2, RED, 320, 0, 117);
			printCenteredText("it couldn't be",       2, RED, 320, 0, 136);
			printCenteredText("initialized.",         2, RED, 320, 0, 155);
			break;
		case FILE_ERROR:
			printCenteredText("ERROR", 5, RED, 320, 0, 71);
			printCenteredText("The required file", 2, RED, 320, 0, 117);
			printCenteredText("couldn't be created", 2, RED, 320, 0, 136);
			break;
		case WRITE_ERROR:
			printCenteredText("ERROR", 5, RED, 320, 0, 71);
			printCenteredText("Couldn't write to", 2, RED, 320, 0, 117);
			printCenteredText("file. Card may have", 2, RED, 320, 0, 136);
			printCenteredText("been removed.", 2, RED, 320, 0, 155);
			break;
	}
	while (1) {
		delay(5000);
	}
}
String getDirection(double angle) {
	if (angle >= 337 && angle <= 360) return "N";
	if (angle >= 0   && angle < 22)   return "N";
	if (angle >= 67  && angle < 112)  return "E";
	if (angle >= 157 && angle < 202)  return "S";
	if (angle >= 247 && angle < 292)  return "W";
	if (angle >= 22  && angle < 67)   return "NE";
	if (angle >= 112 && angle < 157)  return "SE";
	if (angle >= 202 && angle < 247)  return "SW";
	if (angle >= 292 && angle < 337)  return "NW";
}

void setup() {
	Serial.begin(115200);
	display.reset();
	display.begin(display.readID());
	display.setRotation(1);
	display.fillScreen(BLACK);
	display.drawBitmap(96, 43, volvo_2_top, 128, 48, GREY);
	display.drawBitmap(96, 92, volvo_2_middle, 128, 28, VOLVOBLUE);
	display.drawBitmap(96, 121, volvo_2_bottom, 128, 47, GREY);
	printCenteredText("Initializing...", 2, WHITE, 320, 0, 188);
	sensors.begin();
	ts.begin();
	pinMode(LEDPIN, OUTPUT);

	screens[0] = new SummaryScreen();
	screens[1] = new SpeedScreen();
	screens[2] = new DirectionScreen();
	screens[3] = new TemperatureScreen();
	screens[4] = new AltitudeScreen();
	screens[5] = new SatellitesScreen();
	screens[6] = new LogsAndPointsScreen();
	screens[7] = new SettingsScreen();
	screens[8] = new BlankScreen();

	// make sure that the default chip select pin is set to
	// output, even if you don't use it:
	pinMode(CHIPSELECT, OUTPUT);
	pinMode(DISPLAYBUTTON, OUTPUT);
	// see if the card is present and can be initialized:
	if (!SD.begin(CHIPSELECT, 11, 12, 13)) {
		error(INIT_ERROR);
	}
	printCenteredText("Creating file...", 2, WHITE, 320, 0, 188);

	char filename[15];
	strcpy(filename, "LOG0000.csv");
	for (uint8_t i = 0; i < 10000; i++) {
		filename[3] = '0' + (i/1000)%10;
		filename[4] = '0' + (i/100)%10;
		filename[5] = '0' + (i/10)%10;
		filename[6] = '0' + i%10;

		// create if does not exist, do not open existing, write, sync after write
		if (! SD.exists(filename)) {
			Serial.print(filename);
			Serial.println(" doesn't exist");
			break;
		}
		logs = i+1;
	}

	logfile = SD.open(filename, FILE_WRITE);
	if (!logfile) error(FILE_ERROR);

	printCenteredText("Starting GPS...", 2, WHITE, 320, 0, 188);
	GPS.begin(9600);
	// uncomment this line to turn on RMC (recommended minimum) and GGA (fix data) including altitude
	GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_ALLDATA);
	// uncomment this line to turn on only the "minimum recommended" data
	//GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_RMCONLY);
	// For logging data, we don't suggest using anything but either RMC only or RMC+GGA
	// to keep the log files at a reasonable size
	// Set the update rate
	GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ); // 100 millihertz (once every 10 seconds), 1Hz or 5Hz update rate
	// Turn off updates on antenna status, if the firmware permits it
	GPS.sendCommand(PGCMD_NOANTENNA);

	GPS.sendCommand(PMTK_ENABLE_SBAS);
	GPS.sendCommand(PMTK_ENABLE_WAAS);

	// the nice thing about this code is you can have a timer0 interrupt go off
	// every 1 millisecond, and read data from the GPS for you. that makes the
	// loop code a heck of a lot easier!
	useInterrupt(true);
	display.fillScreen(BLACK);
	printTopBar();
	newGpsStatus.refresh = true;
	screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
	newGpsStatus.refresh = false;

}
// Interrupt is called once a millisecond, looks for any new GPS data, and stores it
SIGNAL(TIMER0_COMPA_vect) {
	char c = GPS.read();
	// if you want to debug, this is a good time to do it!
#ifdef UDR0
	if (GPSECHO)
		if (c) UDR0 = c;
	// writing direct to UDR0 is much much faster than Serial.print
	// but only one character can be written at a time.
#endif
}

void useInterrupt(boolean v) {
	if (v) {
		// Timer0 is already used for millis() - we'll just interrupt somewhere
		// in the middle and call the "Compare A" function above
		OCR0A = 0xAF;
		TIMSK0 |= _BV(OCIE0A);
		usingInterrupt = true;
	} else {
		// do not call the interrupt function COMPA anymore
		TIMSK0 &= ~_BV(OCIE0A);
		usingInterrupt = false;
	}
}

bool firstIteration = true;
void printTopBar() {
	display.setTextColor(BLACK);
	display.setTextSize(2);
	if (firstIteration)
	{
		display.setCursor(3,3);
		display.fillRect(0, 0, 320, 20, GREEN);
		display.print(newDate.getDate());
		display.print("         ");
		display.print(newDate.getTime());
		firstIteration = false;
	} else {
		display.setTextSize(2);
		if (oldDate.day != newDate.day)
		{
			display.fillRect(3,3,10,14, GREEN);
			display.fillRect(15,3,10,14, GREEN);
			display.setCursor(3,3);
			if (GPS.day < 10){
				display.print("0");
				display.print(GPS.day);
			} else {
				display.print(GPS.day);
			}
		}

		if (oldDate.mth != newDate.mth)
		{
			display.fillRect(39,3,10,14, GREEN);
			display.fillRect(51,3,10,14, GREEN);
			display.setCursor(39,3);
			if (GPS.month < 10){
				display.print("0");
				display.print(GPS.month);
			} else {
				display.print(GPS.month);
			}
		}

		if (oldDate.yr != newDate.yr)
		{
			display.fillRect(99,3,10,14, GREEN);
			display.fillRect(111,3,10,14, GREEN);
			display.setCursor(99,3);
			if (GPS.year < 10){
				display.print("0");
				display.print(GPS.year, DEC);
			} else {
				display.print(GPS.year, DEC);
			}
		}

		if (oldDate.hr != newDate.hr)
		{
			display.fillRect(219,3,10,14, GREEN);
			display.fillRect(231,3,10,14, GREEN);
			display.setCursor(219,3);
			if (GPS.hour < 10){
				display.print("0");
				display.print(GPS.hour);
			} else {
				display.print(GPS.hour);
			}
		}

		if (oldDate.min != newDate.min)
		{
			display.fillRect(255,3,10,14, GREEN);
			display.fillRect(267,3,10,14, GREEN);
			display.setCursor(255,3);
			if (GPS.minute < 10){
				display.print("0");
				display.print(GPS.minute);
			} else {
				display.print(GPS.minute);
			}
		}

		if (oldDate.sec != newDate.sec || oldDate.mil != newDate.mil)
		{
			display.fillRect(291,3,10,14, GREEN);
			display.fillRect(303,3,10,14, GREEN);
			display.setCursor(291,3);
      int addSecs = GPS.seconds;
      if (GPS.milliseconds >= 500) addSecs++;
			if (addSecs < 10){
				display.print("0");
				display.print(addSecs);
			} else {
				display.print(addSecs);
			}
		}
	}
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

int oldMaxSpeed = 999;

void drawCircleLine(double degree, double circleX, double circleY, double rBegin, double rEnd, int color) {
	display.drawLine((circleX + (rBegin * cos(degree * 1000.0/57296.0))),
	                 (circleY + (rBegin * sin(degree * 1000.0/57296.0))),
	                 (circleX + (rEnd   * cos(degree * 1000.0/57296.0))),
	                 (circleY + (rEnd   * sin(degree * 1000.0/57296.0))),
	                 color);
}

void logPointToFile(DeviceAddress tempSensor) {
	// Print the current time.
	if (logfile.print(newDate.getISOTimestamp()) == 0)  error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the latitude
	if (logfile.print(GPS.latitudeDegrees,14) == 0)     error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the longitude
	if (logfile.print(GPS.longitudeDegrees,14) == 0)    error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the altitude
	if (logfile.print(GPS.altitude,14) == 0)            error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the temperature.
	if (logfile.println(newGpsStatus.temperature) == 0) error(WRITE_ERROR);

	logfile.flush();
}

double distanceBetweenPoints(double lat1, double lat2, double lon1, double lon2) {
	int R = 6371; // km
	double dLat = (lat2-lat1)*PI/180;
	double dLon = (lon2-lon1)*PI/180;
	lat1 = lat1*PI/180;
	lat2 = lat2*PI/180;

	double a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1) * cos(lat2);
	double c = 2 * atan2(sqrt(a), sqrt(1-a));
	double d = R * c;

	return d;
}

bool hasBeenPressed = false;
double oldLat = NULL, oldLon = NULL;

void loop() {
	if (ts.touched() && !hasBeenPressed) {
		hasBeenPressed = true;

		TS_Point p = ts.getPoint();

		if (currentScreen != 0)
		{
			if (currentScreen == 7) {
				if (20 < p.x && p.x <= 118 && 320 >= p.y && p.y > 213){
					textColor = BLUE;
				}
				if (20 < p.x && p.x <= 118 && 213 >= p.y && p.y > 107) {
					textColor = GREEN;
				}
			}
			currentScreen = 0;
		} else {
			for (int i = 1; i < 9; i++) {
				if (screens[i]->wasTapped(p.x, p.y)) {
					currentScreen = i;
					break;
				}
			}
		}
		display.fillRect(0,20,320,240, BLACK);
		newGpsStatus.refresh = true;

		screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
		newGpsStatus.refresh = false;
	} else if (!ts.touched()) {
		hasBeenPressed = false;
	}

	// if a sentence is received, we can check the checksum, parse it...
	if (GPS.newNMEAreceived()) {

		// a tricky thing here is if we print the NMEA sentence, or data
		// we end up not listening and catching other sentences!
		// so be very wary if using OUTPUT_ALLDATA and trying to print out data

		// Don't call lastNMEA more than once between parse calls!  Calling lastNMEA
		// will clear the received flag and can cause very subtle race conditions if
		// new data comes in before parse is called again.

		char *stringptr = GPS.lastNMEA();

		if (!GPS.parse(stringptr))   // this also sets the newNMEAreceived() flag to false
			return;  // we can fail to parse a sentence in which case we should just wait for another

		// Sentence parsed! Display updated data!
		newDate.updateDate(GPS.year, GPS.month, GPS.day, GPS.hour, GPS.minute, GPS.seconds, GPS.milliseconds);
		newGpsStatus.updateStatus(GPS.speed*1.852, GPS.angle, GPS.altitude, GPS.HDOP, GPS.latitudeDegrees, GPS.longitudeDegrees, GPS.satellites, GPS.fix);
		printTopBar();

		// Disabling the temperature readings.
		// Read temperature from the sensor.
		//sensors.requestTemperatures();
		//double temp;
		//if (sensors.getAddress(tempDeviceAddress, 0)) {
		//	newGpsStatus.temperature = sensors.getTempC(tempDeviceAddress);
		//} else {
		//	newGpsStatus.temperature = NULL;
		//}

		// Update the max speed.
		if (newGpsStatus.speed > newGpsStatus.maxSpeed)
			newGpsStatus.maxSpeed = newGpsStatus.speed;

		newGpsStatus.acceleration = newGpsStatus.speed - oldGpsStatus.speed;


		// Calculate the distance between the old and new points.
		if (oldGpsStatus.lat != NULL && oldGpsStatus.lon != NULL) {
			newGpsStatus.distance += distanceBetweenPoints(oldGpsStatus.lat,
			                                               newGpsStatus.lat,
			                                               oldGpsStatus.lon,
			                                               newGpsStatus.lon);
			// This will do for now.
			newGpsStatus.avgSpeed = newGpsStatus.distance/newGpsStatus.points*60*60;
		}

		// Rad. lets log it! Only if the GPS has aquired a fix!
		if ((!(LOG_FIXONLY && !GPS.fix)) && strstr(stringptr, "RMC")){
			logPointToFile(tempDeviceAddress);
			newGpsStatus.points++;
		}

		// Display the selected screen.
		screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);

		// Do not refresh the elements that do not have to be refreshed again.
		newGpsStatus.refresh = false;

		oldGpsStatus = newGpsStatus;
		oldDate      = newDate;
	}
}