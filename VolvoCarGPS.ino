// Volvo Car GPS with Touch Screen UI
#include <SPI.h>
#include <Adafruit_GPS.h>
#include <SoftwareSerial.h>
#include <SD.h>
#include <Wire.h>
#include <Adafruit_GFX.h>    // Core graphics library
#include <Adafruit_TFTLCD.h> // Hardware-specific library
#include <avr/sleep.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_FT6206.h>
#include <math.h>
#include "SharedFunctions.cpp"

Adafruit_GPS      GPS(&Serial1);                                      // Library driver for the GPS.
Adafruit_TFTLCD   display(LCD_CS, LCD_CD, LCD_WR, LCD_RD, LCD_RESET); // Library driver for the TFT LCD.
Adafruit_FT6206   ts = Adafruit_FT6206();                             // Library driver for the touch.
OneWire           oneWire(ONE_WIRE_BUS);                              // Library for the digital temperature sensor.
DallasTemperature sensors(&oneWire);                                  // Library for the digital temperature sensor.
DeviceAddress     tempDeviceAddress;                                  // Library for the digital temperature sensor.
File              logfile;                                            // The file to write to.
SharedFunctions   sharedFunc;
enum ScreenName {
	SUMMARY,
	SPEED,
	DIRECTION,
	TEMPERATURE,
	ALTITUDE,
	SATELLITES,
	LOGSANDPOINTS,
	SETTINGS,
	BLANK
};

int          currentScreen = SATELLITES,
			 oldCurrScreen = -1;         // The current screen that is displayed.

bool         wasPressed = false,        // Tells if the screen has already been pressed.
			 gotFix = false,            // Tells if the GPS has gotten a fix since start.
			 usingInterrupt = false;    // Tells if we should use interrupts for parsing NMEA data.

unsigned int logs = 0;                  // The number of the log on the SD card currently written to.

unsigned int backgroundColor = BLACK;
unsigned int textColor       = GREEN;

const unsigned char  PROGMEM volvo_2_top [] = {
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11111111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00000001, B11111111, B11110000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11000000, B00000000, B00001111, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B11111111, B11111000, B00000000, B00000011, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000000, B11111111, B00000000, B01111111, B11111111, B11111111, B11111111, B00000000, B00000001, B11111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00000011, B11111000, B00000000, B01111111, B11111111, B11111111, B11111111, B11000000, B00000000, B01111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00001111, B11000000, B00000000, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00111111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B00111111, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11111100, B00000000, B00001111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000000, B11111100, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11111110, B00000000, B00000111, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000001, B11110000, B00000000, B00000111, B11111111, B11111111, B11111111, B11111111, B11111111, B10000000, B00110011, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00000111, B11000000, B00000000, B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11100000, B01111001, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00001111, B10000000, B00000000, B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11110000, B11111110, B11111111, B11111100,
	B00000000, B00000000, B00000000, B00011110, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111001, B11111111, B01111111, B11111100,
	B00000000, B00000000, B00000000, B01111100, B00000000, B00000000, B11111111, B00000000, B00000000, B11111111, B11111111, B11111111, B11110011, B11111111, B00111111, B11111100,
	B00000000, B00000000, B00000000, B11110000, B00000000, B00000011, B11100000, B00000000, B00000000, B00000111, B11111111, B11111111, B11100111, B11111111, B10011111, B11111100,
	B00000000, B00000000, B00000001, B11100000, B00000000, B00000111, B00000001, B11000000, B00000000, B00000000, B11111111, B11111111, B11001111, B11111111, B11001111, B11111100,
	B00000000, B00000000, B00000011, B11000000, B00000000, B00001100, B00011111, B11111100, B00000000, B00000000, B00111111, B11111111, B10011111, B11111111, B11100111, B11111100,
	B00000000, B00000000, B00000111, B10000000, B00000000, B00010000, B11111111, B11111111, B10000000, B00000000, B00000111, B11111111, B00111111, B11111111, B11110011, B11111100,
	B00000000, B00000000, B00001111, B00000000, B00000000, B00000011, B11111111, B11111111, B11100000, B00000000, B00000001, B11111110, B01111111, B11111111, B11111011, B11111100,
	B00000000, B00000000, B00011110, B00000000, B00000000, B00011111, B11111111, B11111111, B11110000, B00000000, B00000000, B11111110, B11111111, B11111111, B11111101, B11111100,
	B00000000, B00000000, B00111100, B00000000, B00000000, B00111111, B11111111, B11111111, B11111000, B00000000, B00000000, B00111111, B11111111, B11111111, B11111100, B11111100,
	B00000000, B00000000, B01111000, B00000000, B00000000, B11111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00011111, B11111111, B11111111, B11111110, B11111100,
	B00000000, B00000000, B11110000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000111, B11111111, B11111111, B11111100, B01111100,
	B00000000, B00000000, B11100000, B00000000, B00000111, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00000011, B11111111, B11111111, B11111000, B00111100,
	B00000000, B00000001, B11000000, B00000000, B00001111, B11111111, B11111111, B11100000, B00000111, B11111110, B00000000, B00000001, B11111111, B11111111, B11110000, B00111100,
	B00000000, B00000011, B10000000, B00000000, B00111111, B11111111, B11111100, B00000000, B00000000, B00111111, B10000000, B00000000, B11111111, B11111111, B11100000, B00011100,
	B00000000, B00000111, B10000000, B00000000, B01111111, B11111111, B11100000, B00000000, B00000000, B00000111, B11100000, B00000000, B01111111, B11111111, B11100000, B00001100,
	B00000000, B00000111, B00000000, B00000000, B11111111, B11111111, B10000000, B00000000, B00000000, B00000001, B11111000, B00000000, B00111111, B11111111, B11100000, B00001100,
	B00000000, B00001110, B00000000, B00000001, B11111111, B11111110, B00000000, B00000000, B00000000, B00000000, B01111100, B00000000, B00011111, B11111111, B11110000, B00000100,
	B00000000, B00001110, B00000000, B00000011, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00011110, B00000000, B00001111, B11111111, B11110000, B00000100,
	B00000000, B00011100, B00000000, B00000111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000111, B10000000, B00000111, B11111111, B11111000, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11000000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11100000, B00000001, B11111111, B11111100, B00000000,
	B00000000, B01110000, B00000000, B00011111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11110000, B00000001, B11111111, B11111110, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01111000, B00000000, B11111111, B11111110, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00111100, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011110, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11000000, B00000000, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001111, B00000000, B00111111, B11111111, B00000000,
	B00000001, B11000000, B00000000, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B00000000, B00111111, B11111111, B10000000,
	B00000001, B10000000, B00000001, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B10000000, B00011111, B11111111, B10000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00011111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00001111, B11111111, B11000000,
	B00000011, B00000000, B00000011, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00001111, B11111111, B11000000,
	B00000111, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000111, B11111111, B11100000,
	B00000111, B00000000, B00000111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000111, B11111111, B11100000,
	B00000111, B00000000, B00001111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000011, B11111111, B11100000,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100
};
const unsigned char  PROGMEM volvo_2_middle [] = {
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B10000000, B00000001, B11000000, B00001111, B10000000, B11111110, B00000000, B00001110, B00000000, B00000111, B00000000, B00111110, B00000011, B11111111, B11111110,
	B11111111, B10000000, B00000001, B11000000, B00001100, B00000000, B00011110, B00000000, B00001110, B00000000, B00000111, B00000000, B00110000, B00000000, B01111111, B11111110,
	B11111111, B11110000, B00000111, B11110000, B01111000, B00001000, B00001111, B11000000, B00011111, B11000000, B00011111, B11000001, B11100000, B00100000, B00111111, B11111111,
	B11111111, B11111000, B00000111, B11110000, B01110000, B00011110, B00000111, B11000000, B01111111, B11100000, B00011111, B11000001, B11000000, B11111000, B00011111, B11111111,
	B11111111, B11111100, B00000011, B11110000, B11100000, B00111110, B00000011, B11000000, B01111111, B11110000, B00001111, B11000011, B10000000, B11111000, B00001111, B11111111,
	B11111111, B11111100, B00000011, B11100000, B11100000, B00111111, B00000011, B11000000, B01111111, B11110000, B00001111, B10000111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111110, B00000001, B11100001, B11100000, B00111111, B00000011, B11000000, B01111111, B11111000, B00000111, B10000111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111110, B00000001, B11000011, B11100000, B00111111, B00000011, B11000000, B01111111, B10011000, B00000111, B00001111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111111, B00000000, B11000011, B11100000, B00111111, B00000011, B11000000, B01111111, B00011100, B00000011, B00001111, B10000000, B11111100, B00001111, B11111111,
	B11111111, B11111111, B00000000, B00000111, B11100000, B00111110, B00000011, B11000000, B01111111, B00011100, B00000000, B00011111, B10000000, B11111000, B00001111, B11111111,
	B01111111, B11111111, B10000000, B00000111, B11110000, B00011110, B00000111, B11000000, B01111110, B00011110, B00000000, B00011111, B11000000, B01111000, B00011111, B11111111,
	B01111111, B11111111, B11000000, B00001111, B11111000, B00001100, B00001111, B11000000, B00111000, B00011110, B00000000, B00111111, B11100000, B00110000, B00111111, B11111110,
	B01111111, B11111111, B11000000, B00001111, B11111100, B00000000, B00011110, B00000000, B00000000, B00011111, B00000000, B00111111, B11110000, B00000000, B01111111, B11111110,
	B01111111, B11111111, B11100000, B00011111, B11111111, B00000000, B01111110, B00000000, B00000000, B00011111, B10000000, B01111111, B11111100, B00000001, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111110,
	B01111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100
};
const unsigned char  PROGMEM volvo_2_bottom [] = {
	B00111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111100,
	B00011111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111111, B11111000,
	B00000111, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000111, B11111111, B11100000,
	B00000011, B00000000, B00000111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00001111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00001111, B11111111, B11000000,
	B00000011, B10000000, B00000011, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B11000000, B00011111, B11111111, B11000000,
	B00000001, B10000000, B00000001, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000011, B10000000, B00011111, B11111111, B10000000,
	B00000001, B11000000, B00000001, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B00000000, B00111111, B11111111, B10000000,
	B00000001, B11000000, B00000000, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001111, B00000000, B00111111, B11111111, B10000000,
	B00000000, B11100000, B00000000, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001110, B00000000, B01111111, B11111111, B00000000,
	B00000000, B11100000, B00000000, B01111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011100, B00000000, B01111111, B11111111, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00111000, B00000000, B11111111, B11111110, B00000000,
	B00000000, B01110000, B00000000, B00111111, B11111110, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B01110000, B00000001, B11111111, B11111110, B00000000,
	B00000000, B00111000, B00000000, B00011111, B11111111, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11100000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00111000, B00000000, B00001111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000, B00000011, B11000000, B00000011, B11111111, B11111100, B00000000,
	B00000000, B00011100, B00000000, B00000111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000111, B10000000, B00000111, B11111111, B11111000, B00000000,
	B00000000, B00011100, B00000000, B00000011, B11111111, B11111000, B00000000, B00000000, B00000000, B00000000, B00011111, B00000000, B00001111, B11111111, B11111000, B00000000,
	B00000000, B00001110, B00000000, B00000001, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00111110, B00000000, B00011111, B11111111, B11110000, B00000000,
	B00000000, B00000111, B00000000, B00000000, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00111111, B11111111, B11100000, B00000000,
	B00000000, B00000111, B00000000, B00000000, B01111111, B11111111, B11100000, B00000000, B00000000, B00000011, B11100000, B00000000, B01111111, B11111111, B11100000, B00000000,
	B00000000, B00000011, B10000000, B00000000, B00111111, B11111111, B11111100, B00000000, B00000000, B00011111, B11000000, B00000000, B11111111, B11111111, B11000000, B00000000,
	B00000000, B00000001, B11000000, B00000000, B00011111, B11111111, B11111111, B10000000, B00000001, B11111110, B00000000, B00000001, B11111111, B11111111, B10000000, B00000000,
	B00000000, B00000001, B11100000, B00000000, B00001111, B11111111, B11111111, B11111111, B11111111, B11111000, B00000000, B00000111, B11111111, B11111111, B00000000, B00000000,
	B00000000, B00000000, B11110000, B00000000, B00000011, B11111111, B11111111, B11111111, B11111111, B11100000, B00000000, B00001111, B11111111, B11111111, B00000000, B00000000,
	B00000000, B00000000, B01110000, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11000000, B00000000, B00011111, B11111111, B11111110, B00000000, B00000000,
	B00000000, B00000000, B00111000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B10000000, B00000000, B01111111, B11111111, B11111100, B00000000, B00000000,
	B00000000, B00000000, B00011100, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B00000000, B00000001, B11111111, B11111111, B11111000, B00000000, B00000000,
	B00000000, B00000000, B00001110, B00000000, B00000000, B00000111, B11111111, B11111111, B11111110, B00000000, B00000011, B11111111, B11111111, B11110000, B00000000, B00000000,
	B00000000, B00000000, B00000111, B00000000, B00000000, B00000000, B11111111, B11111111, B11111000, B00000000, B00011111, B11111111, B11111111, B11100000, B00000000, B00000000,
	B00000000, B00000000, B00000011, B10000000, B00000000, B00000000, B00011111, B11111111, B11100000, B00000000, B01111111, B11111111, B11111111, B11000000, B00000000, B00000000,
	B00000000, B00000000, B00000001, B11100000, B00000000, B00000000, B00000000, B11111111, B00000000, B00000011, B11111111, B11111111, B11111111, B10000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B11110000, B00000000, B00000000, B00000000, B00000000, B00000000, B00011111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B01111000, B00000000, B00000000, B00000011, B10000000, B00000111, B11111111, B11111111, B11111111, B11111110, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00111110, B00000000, B00000000, B00000000, B01111111, B11111111, B11111111, B11111111, B11111111, B11111100, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00001111, B00000000, B00000000, B00000000, B00001111, B11111111, B11111111, B11111111, B11111111, B11110000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000111, B11000000, B00000000, B00000000, B00000001, B11111111, B11111111, B11111111, B11111111, B11100000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000011, B11100000, B00000000, B00000000, B00000000, B00111111, B11111111, B11111111, B11111111, B10000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00000000, B00000000, B00000111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00111110, B00000000, B00000000, B00000000, B00000001, B11111111, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00001111, B11000000, B00000000, B00000000, B00000000, B01111111, B11111111, B11110000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000111, B11110000, B00000000, B00000000, B00000000, B00111111, B11111111, B11000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B11111110, B00000000, B00000000, B00000000, B01111111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00111111, B11100000, B00000000, B00000000, B11111111, B11111100, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111, B00000000, B00000011, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B11111111, B11111111, B11111111, B11111111, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111, B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
	B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001, B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000
};

enum Error {
	INIT_ERROR,
	FILE_ERROR,
	WRITE_ERROR
};

// A custom map function for float numbers.
float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

// A function that draws a line between two radius points of a circle, rBegin and rEnd, of a chosen degree
// with the center of the circle at the point (circleX, circleY).
void drawCircleLine(double degree, double circleX, double circleY, double rBegin, double rEnd, int color) {
	display.drawLine((circleX + (rBegin * cos(degree * 1000.0/57296.0))),
					 (circleY + (rBegin * sin(degree * 1000.0/57296.0))),
					 (circleX + (rEnd   * cos(degree * 1000.0/57296.0))),
					 (circleY + (rEnd   * sin(degree * 1000.0/57296.0))),
					 color);
}

void printCenteredText(String text, int textSize, int color, int areaWidth, int offset, int y) {
	int x = (areaWidth-(text.length()*textSize*5+textSize*(text.length()-1)))/2+offset;
	display.setTextSize(textSize);
	display.setCursor(x,y);
	display.setTextColor(color);
	display.fillRect(offset+1,y,areaWidth-2,textSize*8, backgroundColor);
	display.print(text);
}



// blink out an error code
void error(Error error) {
	display.fillScreen(BLACK);
	switch (error) {
		case INIT_ERROR:
			printCenteredText("ERROR",                5, RED, 320, 0, 71);
			printCenteredText("SD card not found or", 2, RED, 320, 0, 117);
			printCenteredText("it couldn't be",       2, RED, 320, 0, 136);
			printCenteredText("initialized.",         2, RED, 320, 0, 155);
			break;
		case FILE_ERROR:
			printCenteredText("ERROR",               5, RED, 320, 0, 71);
			printCenteredText("The required file",   2, RED, 320, 0, 117);
			printCenteredText("couldn't be created", 2, RED, 320, 0, 136);
			break;
		case WRITE_ERROR:
			printCenteredText("ERROR",               5, RED, 320, 0, 71);
			printCenteredText("Couldn't write to",   2, RED, 320, 0, 117);
			printCenteredText("file. Card may have", 2, RED, 320, 0, 136);
			printCenteredText("been removed.",       2, RED, 320, 0, 155);
			break;
	}
	while (1) {
		delay(5000);
	}
}

struct DisplayDate {
	int sec, min, hr, day, mth, yr, mil;

	DisplayDate(int yr, int mth, int day, int hr, int min, int sec, int mil) {
		this->yr  = yr;
		this->mth = mth;
		this->day = day;
		this->hr  = hr;
		this->min = min;
		this->sec = sec;
		this->mil = mil;
	}

	void updateDate(int yr, int mth, int day, int hr, int min, int sec, int mil) {
		this->yr  = yr;
		this->mth = mth;
		this->day = day;
		this->hr  = hr;
		this->min = min;
		this->sec = sec;
		this->mil = mil;
	}

	String getDate() {
		String date;
		this->day < 10 ? date.concat("0"):false;
		date.concat(String(day));
		date.concat(".");
		this->mth < 10 ? date.concat("0"):false;
		date.concat(String(mth));
		date.concat(".");
		date.concat("20");
		this->yr < 10 ? date.concat("0"):false;
		date.concat(String(yr));
		return date;
	}

	String getTime() {
		String date;
		this->hr < 10 ? date.concat("0"):false;
		date.concat(String(hr));
		date.concat(":");
		this->min < 10 ? date.concat("0"):false;
		date.concat(String(min));
		date.concat(":");
		this->sec < 10 ? date.concat("0"):false;
		date.concat(String(this->sec));
		return date;
	}

	String getISOTimestamp() {
		String isoDate;
		isoDate.concat("20");
		if (this->yr < 10) isoDate.concat('0');
		isoDate.concat(this->yr);
		isoDate += "-";

		if (this->mth < 10) isoDate.concat('0');
		isoDate.concat(this->mth);
		isoDate.concat('-');

		if (this->day < 10) isoDate.concat('0');
		isoDate.concat(this->day);

		isoDate.concat('T');

		if (this->hr < 10) isoDate.concat('0');
		isoDate.concat(this->hr);
		isoDate.concat(':');

		if (this->min < 10) isoDate.concat('0');
		isoDate.concat(this->min);
		isoDate.concat(':');

		if (this->sec < 10) isoDate.concat('0');
		isoDate.concat(this->sec);
		isoDate.concat('.');

		isoDate.concat(this->mil);
		isoDate.concat('Z');
		return isoDate;
	}
};
DisplayDate newDate(GPS.year, GPS.month, GPS.day, GPS.hour, GPS.minute, GPS.seconds, GPS.milliseconds);
DisplayDate oldDate(0,0,0,0,0,0,0);

struct GPS_Status
{
	DisplayDate date();

	double speed,
		   angle,
		   temperature,
		   minTemp,
		   maxTemp,
		   altitude,
		   acceleration,
		   hdop,
		   vdop,
		   pdop,
		   distance,
		   avgSpeed,
		   maxSpeed,
		   lat,
		   lon;

	bool refresh;

	int satellites,
		fix,
		fixquality,
		satellitesInView;
	
	uint32_t points;


	GPS_Status() {
		this->speed            = NULL;
		this->angle            = NULL;
		this->temperature      = NULL;
		this->altitude         = NULL;
		this->acceleration     = NULL;
		this->hdop             = NULL;
		this->vdop             = NULL;
		this->pdop             = NULL;
		this->points           = NULL;
		this->distance         = NULL;
		this->avgSpeed         = NULL;
		this->maxSpeed         = NULL;
		this->lat              = NULL;
		this->lon              = NULL;
		this->satellitesInView = NULL;
		this->fixquality       = NULL;
	}

	GPS_Status(double speed, double angle, double altitude, double hdop, double vdop, double pdop, double lat, double lon, int satellites, int fix, int satellitesInView, int fixquality) {
		this->speed            = speed;
		this->angle            = angle;
		this->altitude         = altitude;
		this->hdop             = hdop;
		this->vdop             = vdop;
		this->pdop             = pdop;
		this->lat              = lat;
		this->lon              = lon;
		this->satellites       = satellites;
		this->fix              = fix;
		this->fixquality       = fixquality;
		this->satellitesInView = satellitesInView;
	}
	void updateStatus(double speed, double angle, double altitude, double hdop, double vdop, double pdop, double lat, double lon, int satellites, int fix, int satellitesInView, int fixquality) {
		this->speed            = speed;
		this->angle            = angle;
		this->altitude         = altitude;
		this->hdop             = hdop;
		this->vdop             = vdop;
		this->pdop             = pdop;
		this->lat              = lat;
		this->lon              = lon;
		this->satellites       = satellites;
		this->fix              = fix;
		this->fixquality       = fixquality;
		this->satellitesInView = satellitesInView;
	}
};
GPS_Status newGpsStatus;
GPS_Status oldGpsStatus;

class Screen
{
	public:
	virtual void displayScreen(GPS_Status* data, GPS_Status* oldData);
	virtual bool wasTapped(int x, int y);
};
Screen*           screens[9];

class SummaryScreen: public Screen
{

	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displaySpeed() {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, textColor, 107, 0, 30);
		}
		double acceleration;
		if (newStatus->speed != oldStatus->speed || newStatus->refresh) {
			if (newStatus->speed < 10)                                   printCenteredText(String(newStatus->speed, 2), 3, textColor, 107, 0, 64);
			else if (newStatus->speed >= 10 && newStatus->speed < 100)   printCenteredText(String(newStatus->speed, 2), 3, textColor, 107, 0, 64);
			else if (newStatus->speed >= 100 && newStatus->speed < 1000) printCenteredText(String(newStatus->speed, 1), 3, textColor, 107, 0, 64);
			else if (newStatus->speed >= 1000)                           printCenteredText(String(newStatus->speed, 0), 3, textColor, 107, 0, 64);
			printCenteredText(String(newStatus->acceleration, 2), 2, textColor, 107, 0, 95);
		}
	}

	void displayDirection() {

		if (newStatus->refresh) {
			printCenteredText("DIRECTION", 1, textColor, 107, 107, 30);
		}

		String dir = sharedFunc.getDirection(newStatus->angle);

		if (sharedFunc.getDirection(oldStatus->angle) != dir || newStatus->refresh) {
			printCenteredText(dir, 3, textColor, 107, 107, 64);
		}

		if (oldStatus->angle != newStatus->angle || newStatus->refresh) {
			printCenteredText(String(newStatus->angle), 2, textColor, 107, 107, 95);
		}
	}

	void displayTemperature() {
		if (newStatus->refresh) {
			printCenteredText("TEMPERATURE", 1, textColor, 107, 214, 30);
		}

		if (oldStatus->temperature != newStatus->temperature || newStatus->refresh) {

			if (newStatus->temperature != NULL) {
				if      (newStatus->temperature <= -100 || newStatus->temperature >= 1000)
					printCenteredText(String(newStatus->temperature, 0), 3, textColor, 107, 214, 64);
				else if ((newStatus->temperature <= -10 && newStatus->temperature > -100) ||
						 (newStatus->temperature >= 100 && newStatus->temperature < 1000))
					printCenteredText(String(newStatus->temperature, 1), 3, textColor, 107, 214, 64);
				else if (-10 < newStatus->temperature && newStatus->temperature < 100)
					printCenteredText(String(newStatus->temperature, 2), 3, textColor, 107, 214, 64);
			} else {
				printCenteredText("DISC", 3, textColor, 107, 214, 64);
			}
		}
	}

	void displayAltitude() {
		if (newStatus->refresh) {
			display.setCursor(30,128);
			display.setTextSize(1);
			display.print("ALTITUDE");
		}
		if (oldStatus->altitude != newStatus->altitude || newStatus->refresh) {
			if      (newStatus->altitude <= -100 || newStatus->altitude >= 1000)   printCenteredText(String(newStatus->altitude, 0), 3, textColor, 107, 214, 162);
			else if ((newStatus->altitude <= -10 && newStatus->altitude > -100) ||
					 (newStatus->altitude >= 100 && newStatus->altitude < 1000))   printCenteredText(String(newStatus->altitude, 1), 3, textColor, 107, 0, 162);
			else if (-10 < newStatus->altitude && newStatus->altitude < 100)       printCenteredText(String(newStatus->altitude, 2), 3, textColor, 107, 0, 162);
		}
	}

	void displaySatellites() {
		if (newStatus->refresh) {
			display.setCursor(131,128);
			printCenteredText("SATELLITES", 1, textColor, 107, 107, 128);
		}
		if (oldStatus->fixquality != newStatus->fixquality || newStatus->refresh) {
			if(newStatus->fixquality == 2){
				printCenteredText("D-GPS", 1, textColor, 107, 107, 141);
			} else {
				printCenteredText("", 1, textColor, 107, 107, 141);

			}
			printCenteredText(String(newStatus->satellites) + "/" + GPS.satellitesInView, 3, textColor, 107, 107, 162);
		}
		if (oldStatus->satellitesInView != GPS.satellitesInView || oldStatus->satellites != newStatus->satellites || newStatus->refresh) {
			printCenteredText(String(newStatus->satellites) + "/" + GPS.satellitesInView, 3, textColor, 107, 107, 162);
		}

		if (oldStatus->hdop != newStatus->hdop || newStatus->refresh) {
			printCenteredText(String(newStatus->hdop, 2), 2, textColor, 107, 107, 193);
		}
	}

	void displayLogsAndPoints(int logNumber) {
		if (newStatus->refresh) {
			printCenteredText("LOG", 1, textColor, 107, 214, 128);
			printCenteredText("POINTS", 1, textColor, 107, 214, 174);
			printCenteredText(String(logNumber), 2, textColor, 107, 214, 142);
		}

		if (oldStatus->points != newStatus->points || newStatus->refresh) {
			printCenteredText(String(newStatus->points), 2, textColor, 107, 214, 188);
		}
	}

	void displayOutlines() {
		if (newStatus->refresh) {
			display.drawFastVLine(107,20, 195, textColor);
			display.drawFastVLine(213,20, 195, textColor);
			display.drawFastHLine(0, 118, 320, textColor);
			display.drawFastHLine(0, 215, 320, textColor);
		}
	}

	void displayGPSStatus(int fix, double lat, double lon) {
		display.setTextColor(textColor);
		display.setTextSize(2);
		if (GPS.fix) {
			display.setCursor(35,221);
			if (newGpsStatus.lat != oldGpsStatus.lat ||
				newGpsStatus.lon != oldGpsStatus.lon || newStatus->refresh || newStatus->fix != oldStatus->fix) {

				display.fillRect(35,221,250,16, backgroundColor);
				display.print(GPS.lat);
				display.print(" ");
				GPS.lat == 'N' ? display.print(GPS.latitudeDegrees, 4) : display.print((-1)*GPS.latitudeDegrees, 4);
				display.print("   ");
				display.print(GPS.lon);
				display.print(" ");
				GPS.lon == 'W' ? display.print((-1)*GPS.longitudeDegrees, 4) : display.print(GPS.longitudeDegrees, 4);
			}
		}
		else {

			if (newGpsStatus.fix != oldGpsStatus.fix || newStatus->refresh)
			{
				display.fillRect(0,216,320,25, backgroundColor);
				if (!gotFix) {
					display.setCursor(41,221);
					display.setTextColor(BLUE);
					display.print("Acquiring Satellites");
				} else {
					display.setCursor(71,221);
					display.setTextColor(RED);
					display.print("Lost Satellites");
				}
			}
		}
	}
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData) {
		this->newStatus = data;
		this->oldStatus = oldData;

		displayOutlines();
		displaySpeed();
		displayDirection();
		displayTemperature();
		displayAltitude();
		displaySatellites();
		displayLogsAndPoints(logs);
		displayGPSStatus(GPS.fix, GPS.latitudeDegrees, GPS.longitudeDegrees);
	}

	bool wasTapped(int x, int y) {
		return false;
	}
};

class SpeedScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displayDataFieldOutlines() {
		display.drawLine(0,60,340,60,textColor);
		display.drawLine(0,100,80,100,textColor);
		display.drawLine(240,100,320,100,textColor);

		display.drawLine(80,20,80,100,textColor);
		display.drawLine(160,20,160,60,textColor);
		display.drawLine(240,20,240,100,textColor);
	}

	void displaySpeedometerOutlines() {
		display.drawCircle(160,240,150,textColor);
		for (int i = 1; i < MAX_SPEED; i++) {
			if (i % 10 == 0) {
				drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 135, textColor);
				continue;
			}

			if (i % 5 == 0) {
				drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 140, textColor);
				continue;
			}
			drawCircleLine(mapfloat(i, 0, MAX_SPEED, 180, 360), 160, 239, 148, 145, textColor);
		}
	}

	void displaySpeedometerUpdated(float speed, float avgSpeed, float maxSpeed) {
		display.setTextSize(1);
		display.setTextColor(textColor);
		display.setCursor(40, 194);  display.print(10);
		display.setCursor(62, 157);  display.print(20);
		display.setCursor(92, 128);  display.print(30);
		display.setCursor(133, 113); display.print(40);
		display.setCursor(176, 113); display.print(50);
		display.setCursor(217, 128); display.print(60);
		display.setCursor(247, 157); display.print(70);
		display.setCursor(269, 194); display.print(80);
		//display.drawBitmap(96, 170, volvo, 128, 17, BLUE);

		float mappedSpeed = mapfloat(speed, 0.0, MAX_SPEED, 180.0, 360.0);
		if (mappedSpeed < 180) mappedSpeed = 180;

		drawCircleLine(mapfloat(oldStatus->speed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 0, 130, backgroundColor);
		drawCircleLine(mapfloat(newStatus->speed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 0, 130, RED);

		drawCircleLine(mapfloat(oldStatus->maxSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, backgroundColor);
		drawCircleLine(mapfloat(newStatus->maxSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, RED);

		drawCircleLine(mapfloat(oldStatus->avgSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, backgroundColor);
		drawCircleLine(mapfloat(newStatus->avgSpeed, 0.0, MAX_SPEED, 180.0, 360.0), 160, 239, 160, 151, BLUE);
	}

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, textColor, 80, 0, 24);
		}
		if (oldStatus->speed != newStatus->speed || newStatus->refresh) {
			printCenteredText(String(newStatus->speed,2), 2, textColor, 80, 0, 38);
		}
	}

	void displayAvgSpeed(float avgSpeed) {
		if (newStatus->refresh) {
			printCenteredText("AVG. SPEED", 1, textColor, 79, 80, 24);
		}
		if (oldStatus->avgSpeed != newStatus->avgSpeed || newStatus->refresh) {
			printCenteredText(String(newStatus->avgSpeed,2), 2, textColor, 80, 80, 38);
		}
	}

	void displayMaxSpeed(float maxSpeed) {
		if (newStatus->refresh) {
			printCenteredText("MAX SPEED", 1, textColor, 79, 160, 24);
		}
		if (oldStatus->maxSpeed != newStatus->maxSpeed || newStatus->refresh) {
			printCenteredText(String(newStatus->maxSpeed,2), 2, textColor, 80, 160, 38);
		}
	}

	void displayDistance(float distance) {
		if (newStatus->refresh) {
			printCenteredText("DISTANCE", 1, textColor, 80, 240, 24);
		}
		if (oldStatus->distance != newStatus->distance || newStatus->refresh) {
			printCenteredText(String(newStatus->distance, 2), 2, textColor, 80, 240, 38);
		}
	}

	void displayAltitude(float altitude) {
		if (newStatus->refresh) {
			printCenteredText("ALTITUDE", 1, textColor, 80, 0, 65);
		}
		if (oldStatus->altitude != newStatus->altitude || newStatus->refresh) {
			printCenteredText(String(newStatus->altitude,1), 2, textColor, 80, 0, 79);
		}
	}

	void displaySatellites(int satellites) {
		if (newStatus->refresh) {
			printCenteredText("SATELLITES", 1, textColor, 80, 240, 65);
		}
		if (oldStatus->satellitesInView != GPS.satellitesInView || oldStatus->satellites != newStatus->satellites || newStatus->refresh) {
			printCenteredText(String(newStatus->satellites) + "/" + GPS.satellitesInView, 2, textColor, 80, 240, 79);
		}
	}

	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData) {
		this->newStatus = newData;
		this->oldStatus = oldData;

		if (newStatus->refresh) {
			displayDataFieldOutlines();
		}
		displaySpeed(GPS.speed*1.852);
		displayAvgSpeed(newStatus->avgSpeed);
		displayMaxSpeed(newStatus->maxSpeed);
		displayDistance(newStatus->distance);
		displayAltitude(GPS.altitude);
		displaySatellites(GPS.satellites);
		if (newStatus->refresh) {
			displaySpeedometerOutlines();
		}
		displaySpeedometerUpdated(GPS.speed*1.852, newStatus->avgSpeed, newStatus->maxSpeed);

	}
	bool wasTapped(int x, int y) {
		return 0 < x && x <= 107 && 20 < y && y < 118;
	}
};

class DirectionScreen: public Screen
{
	float oldAngle, oldSpeed, oldAltitude;
	String oldDirection;
	GPS_Status* newStatus;
	GPS_Status* oldStatus;

	void displayDataFieldOutlines() {
		// Upper Horizontal Lines
		display.drawLine(0,   60, 80, 60,  textColor); // Left
		display.drawLine(240, 60, 320, 60, textColor); // Right

		// Upper Vertical Lines
		display.drawLine(80,20,80,60,textColor);       // Left
		display.drawLine(240,20,240,60,textColor);     // Right

		// Lower Horizontal Lines
		display.drawLine(0,200,80,200,textColor);      // Left
		display.drawLine(240,200,320,200,textColor);   // Right

		// Lower Vertical Lines
		display.drawLine(80,200,80,240,textColor);     // Left
		display.drawLine(240,200,240,240,textColor);   // Right
	}

	void displayDirection(float angle) {
		if (newStatus->refresh) {
			printCenteredText("DIRECTION", 1, textColor, 80, 0,   24);
		}

		String dir = sharedFunc.getDirection(angle);
		if (this->oldDirection != dir || newStatus->refresh) {
			printCenteredText(dir, 2, textColor, 80, 0, 38);
		}
		this->oldDirection = dir;
	}

	void displayAngle(float angle) {
		if (newStatus->refresh) {
			printCenteredText("ANGLE", 1, textColor, 80, 240, 24);
		}

		if (oldAngle != angle || newStatus->refresh) {
			printCenteredText(String(angle,1), 2, textColor, 80, 240, 38);
		}

		this->oldAngle = angle;
	}

	void displaySpeed(float speed) {
		if (newStatus->refresh) {
			printCenteredText("SPEED", 1, textColor, 80, 0,   205);
		}

		if (oldSpeed != speed || newStatus->refresh) {
			printCenteredText(String(speed,2),    2, textColor, 80, 0,   219);
		}

		this->oldSpeed = speed;
	}

	void displayAltitude(float altitude) {
		if (newStatus->refresh) {
			printCenteredText("ALTITUDE",  1, textColor, 80, 240, 205);
		}

		if (oldAltitude != altitude || newStatus->refresh) {
			printCenteredText(String(altitude,2), 2, textColor, 80, 240, 219);
		}

		this->oldAltitude = altitude;
	}

	void displayCompassOutline() {
		display.drawCircle(160, 130, 100, textColor);

		display.drawLine  (259, 130, 250, 130, textColor);
		display.drawLine  (230, 200, 224, 194, textColor);
		display.drawLine  (160, 229, 160, 220, textColor);
		display.drawLine  (90,  200, 96,  194, textColor);
		display.drawLine  (61,  130, 70,  130, textColor);
		display.drawLine  (90,  60,  96,  66,  textColor);
		display.drawLine  (160, 31,  160, 40,  textColor);
		display.drawLine  (230, 60,  224, 66,  textColor);
		display.drawLine  (259, 130, 250, 130, textColor);
	}

	void displayCompassDirection(float angle) {

		if (oldAngle != angle || newStatus->refresh) {
			drawCircleLine(oldAngle, 160,130, 0, 90, backgroundColor);
			drawCircleLine(angle, 160,130, 0, 90, RED);
		}
		oldAngle = angle;
	}

	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData) {
		this->newStatus = newData;
		this->oldStatus = oldData;

		if (newStatus->refresh) {
			displayDataFieldOutlines();
			displayCompassOutline();
		}
		// Not the best solution.
		displayCompassDirection(GPS.angle);
		displayDirection(GPS.angle);
		displayAngle(GPS.angle);
		displaySpeed(GPS.speed*1.852);
		displayAltitude(GPS.altitude);
	}
	bool wasTapped(int x, int y) {
		return 107 < x && x < 213 && 20 < y && y < 118;
	}
};

class TemperatureScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData) {

		newStatus = newData;
		oldStatus = oldData;

		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Temperature:\nWork in progress...");
		}
	}

	bool wasTapped(int x, int y) {
		return 213 < x && x < 320 && 20 < y && y < 118;
	}
};

class AltitudeScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh)
		{
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Altitude:\nWork in progress...");
		}
	}
	bool wasTapped(int x, int y) {
		return 0 < x && x < 107 && 118 < y && y < 215;
	}
};

class SatellitesScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	int screenDivider = 140;
	int sphereX = screenDivider/2, sphereY = 130, sphereR = 68;
	int oldSatellitesIV, oldFixQual;
	Satellite oldSatDetails[20];
	
	void displayDataFieldOutlines() {
		display.drawFastHLine(0,60,340,textColor);

		display.drawLine(80,20,80,60,textColor);
		display.drawLine(160,20,160,60,textColor);
		display.drawLine(240,20,240,60,textColor);
	

		// Lower Horizontal Lines
		display.drawFastHLine(30,200,80,textColor);      // Left

		// Lower Vertical Lines
		display.drawFastVLine(30,200,40,textColor);     // Left
		display.drawFastVLine(110,200,40,textColor);     // Left
	}
	void displaySatellitesInView() {
		if (newStatus->refresh) {
			printCenteredText("SATELLITES",             1, textColor, 80, 0, 24);
		}
		if (oldSatellitesIV != GPS.satellitesInView || oldStatus->satellites != newStatus->satellites || newStatus->refresh) {
			printCenteredText(String(newStatus->satellites) + "/" + GPS.satellitesInView, 2, textColor, 80, 0, 38);
		}

	}

		void displayHDOP() {
		if (newStatus->refresh) {
			printCenteredText("HDOP",             1, textColor, 80, 80, 24);
		}
		if (oldStatus->hdop != newStatus->hdop || newStatus->refresh) {
			printCenteredText(String(newStatus->hdop, 2), 2, textColor, 80, 80, 38);
		}

	}

		void displayVDOP() {
		if (newStatus->refresh) {
			printCenteredText("VDOP",             1, textColor, 80, 160, 24);
		}
		if (oldStatus->vdop != newStatus->vdop || newStatus->refresh) {
			printCenteredText(String(newStatus->vdop, 2), 2, textColor, 80, 160, 38);
		}

	}

		void displayPDOP() {
		if (newStatus->refresh) {
			printCenteredText("PDOP",             1, textColor, 80, 240, 24);
		}
		if (oldStatus->pdop != newStatus->pdop || newStatus->refresh) {
			printCenteredText(String(newStatus->pdop, 2), 2, textColor, 80, 240, 38);
		}

	}

	void displayFix() {
		if (newStatus->refresh) {
			printCenteredText("FIX",  1, textColor, 80, 30, 205);
		}

		if (oldFixQual != GPS.fixquality || newStatus->refresh) {
			if (GPS.fixquality == 0) {
				printCenteredText("No Fix", 2, textColor, 80, 30, 219);
			} else if (GPS.fixquality == 1) {
				printCenteredText("GPS", 2, textColor, 80, 30, 219);
			} else if (GPS.fixquality == 2) {
				printCenteredText("D-GPS", 2, textColor, 80, 30, 219);
			}
			oldFixQual = GPS.fixquality;
		}

	}
	void displayCompassOutline() {
		display.drawCircle(sphereX, sphereY, sphereR, textColor);
		for (int i = 0; i < 360; i = i + 45) {
			drawCircleLine(i, sphereX, sphereY, 0, sphereR, textColor);
		}
		display.drawCircle(sphereX,sphereY,sphereR/2,textColor);
	}
	int setBarWidth(int satellites) {
		switch(satellites) {
			case 1:
				return 179;
			case 2:
				return 90;
			case 3:
				return 59;
			case 4:
				return 44;
			case 5:
				return 35;
			case 6:
				return 29;
			case 7:
				return 25;
			case 8:
				return 22;
			case 9:
				return 19;
			case 10:
				return 17;
			case 11:
				return 15;
			case 12:
				return 14;
			case 13:
				return 13;
			case 14:
				return 12;
			case 15:
				return 11;
			case 16:
				return 10;
			case 17:
				return 9;
			case 18:
				return 9;
			case 19:
				return 8;
			case 20:
				return 8;
			case 21:
				return 7;
			case 22:
				return 7;
		}
		return 12;
	}

	void displaySatellitePoints() {
		if(oldSatellitesIV != GPS.satellitesInView || newStatus->refresh){
			display.fillRect(screenDivider, SCREEN_HEIGHT-220+80, SCREEN_WIDTH-screenDivider, 220, backgroundColor);
		}
		int i;
		for (i = 0; i < GPS.satellitesInView; i++) {
			// Clear the old satellite dots.
			if (i < oldSatellitesIV) {
				int mappedElevation = map(oldSatDetails[i].elevation, 0, 90, sphereR, 0);
				Points p = sharedFunc.getCirclePoint(oldSatDetails[i].azimuth, sphereX, sphereY, mappedElevation);
				display.fillCircle(p.x, p.y, 2, backgroundColor);
			}

			// Display the new satellite dots.
			if (GPS.satelliteDetail[i].prn != NULL) {
				int mappedElevation = map(GPS.satelliteDetail[i].elevation, 0, 90, sphereR, 0);
				Points p = sharedFunc.getCirclePoint(GPS.satelliteDetail[i].azimuth, sphereX, sphereY, mappedElevation);
				if (!GPS.satelliteDetail[i].used) {
					display.fillCircle(p.x, p.y, 2, WHITE);
				} else {
					display.fillCircle(p.x, p.y, 2, GREEN);
				}
			}

			// Update the old bars if they updated.
			if (oldSatDetails[i].snr != GPS.satelliteDetail[i].snr || oldSatDetails[i].prn != GPS.satelliteDetail[i].prn || oldSatellitesIV != GPS.satellitesInView || newStatus->refresh) {
				int width = setBarWidth(GPS.satellitesInView);

				display.fillRect(((width+1)*i)+screenDivider, SCREEN_HEIGHT-220+80, width+1, 200, backgroundColor);
				
				if(GPS.satellitesInView >= 13){
					int mapped = map(GPS.satelliteDetail[i].snr, 0, 99, 0, 210);
					if(GPS.satelliteDetail[i].used){
						display.fillRect(((width+1)*i)+screenDivider, SCREEN_HEIGHT-1-mapped-20, width, mapped, textColor);
					} else {
						display.fillRect(((width+1)*i)+screenDivider, SCREEN_HEIGHT-1-mapped-20, width, mapped, GREY);
					}

					if(i % 2 == 1){
						display.setCursor(((width+1)*i)+screenDivider, SCREEN_HEIGHT-7);
					} else {
						display.setCursor(((width+1)*i)+screenDivider, SCREEN_HEIGHT-17);
					}
				} else {
					int mapped = map(GPS.satelliteDetail[i].snr, 0, 99, 0, 220);
					if(GPS.satelliteDetail[i].used){
						display.fillRect(((width+1)*i)+screenDivider, SCREEN_HEIGHT-1-mapped-10, width, mapped, textColor);
					} else {
						display.fillRect(((width+1)*i)+screenDivider, SCREEN_HEIGHT-1-mapped-10, width, mapped, GREY);
					}
					display.setCursor(((width+1)*i)+screenDivider, SCREEN_HEIGHT-7);
				}


				display.fillRect(display.getCursorX(), display.getCursorY(), 11, 7, backgroundColor);
				if(GPS.satelliteDetail[i].used){
					display.setTextColor(textColor);
				} else {
					display.setTextColor(GREY);
				}
				
				display.setTextSize(1);
				if (GPS.satelliteDetail[i].prn != 0) {
					if(GPS.satelliteDetail[i].prn < 10) display.print(0);
					display.print(GPS.satelliteDetail[i].prn);
				}
			}

			oldSatDetails[i].elevation = GPS.satelliteDetail[i].elevation;
			oldSatDetails[i].azimuth = GPS.satelliteDetail[i].azimuth;
		}
		// Clear the rest of the points.
		for (; i < oldSatellitesIV; i++) {
			int mappedElevation = map(oldSatDetails[i].elevation, 0, 90, sphereR, 0);
			Points p = sharedFunc.getCirclePoint(oldSatDetails[i].azimuth, sphereX, sphereY, mappedElevation);
			display.fillCircle(p.x, p.y, 2, backgroundColor);
		}
	}

	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		displayDataFieldOutlines();
		displayCompassOutline();
		if (newStatus->refresh)
		{
			
		}
		displaySatellitesInView();
		displayHDOP();
		displayVDOP();
		displayPDOP();
		displayFix();
		displaySatellitePoints();

		for (int i = 0; i < 20; i++) {
			oldSatDetails[i] = GPS.satelliteDetail[i];
		}
		oldSatellitesIV = GPS.satellitesInView;

	}
	bool wasTapped(int x, int y) {
		return 107 < x && x < 213 && 118 < y && y < 215;
	}
};

class LogsAndPointsScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh)
		{
			display.drawLine(0,130,320,130,textColor);
			display.setTextSize(2);
			display.setTextColor(textColor);
			display.setCursor(3,23);
			display.print("Time and position:\nWork in progress...");
		}
	}

	bool wasTapped(int x, int y) {
		return 213 < x && x < 320 && 118 < y && y < 215;
	}
};

class SettingsScreen: public Screen
{
	GPS_Status* newStatus;
	GPS_Status* oldStatus;
	public:
	void displayScreen(GPS_Status* newData, GPS_Status* oldData){
		newStatus = newData;
		oldStatus = oldData;
		if (newStatus->refresh) // (String text, int textSize, int color, int areaWidth, int offset, int y)
		{
			display.drawFastVLine(160,20,220, textColor);
			printCenteredText("Text Color", 2, textColor, 160, 0, 24);
			printCenteredText("Backg. Color", 2, textColor, 160, 160, 24);
			display.fillRect(20,50,50,50, GREEN);
			display.fillRect(90,50,50,50, BLUE);

			display.fillRect(20,120,50,50, BLACK);
			display.fillRect(90,120,50,50, WHITE);

			display.fillRect(20,190,50,50, RED);
			display.fillRect(90,190,50,50, YELLOW);

			display.fillRect(160+20,50,50,50, GREEN);
			display.fillRect(160+90,50,50,50, BLUE);

			display.fillRect(160+20,120,50,50, BLACK);
			display.fillRect(160+90,120,50,50, WHITE);

			display.fillRect(160+20,190,50,50, RED);
			display.fillRect(160+90,190,50,50, YELLOW);
		}
	}
	bool wasTapped(int x, int y) {
		return 0 < x && x < 320 && 0 < y && y < 20;
	}
};

class BlankScreen: public Screen
{
	public:
	void displayScreen(GPS_Status* data, GPS_Status* oldData){}

	bool wasTapped(int x, int y) {
		return 0 < x && x < 320 && 215 < y && y < 240;
	}
};

void useInterrupt(boolean);

void setup() {
	Serial.begin(115200);
	display.reset();
	display.begin(display.readID());
	display.setRotation(1);
	display.fillScreen(BLACK);
	display.drawBitmap(96, 43,  volvo_2_top,    128, 48, GREY);
	display.drawBitmap(96, 92,  volvo_2_middle, 128, 28, VOLVOBLUE);
	display.drawBitmap(96, 121, volvo_2_bottom, 128, 47, GREY);
	printCenteredText("Initializing...", 2, WHITE, 320, 0, 188);
	sensors.begin();
	ts.begin();
	pinMode(LEDPIN, OUTPUT);

	screens[SUMMARY]       = new SummaryScreen();
	screens[SPEED]         = new SpeedScreen();
	screens[DIRECTION]     = new DirectionScreen();
	screens[TEMPERATURE]   = new TemperatureScreen();
	screens[ALTITUDE]      = new AltitudeScreen();
	screens[SATELLITES]    = new SatellitesScreen();
	screens[LOGSANDPOINTS] = new LogsAndPointsScreen();
	screens[SETTINGS]      = new SettingsScreen();
	screens[BLANK]         = new BlankScreen();

	// make sure that the default chip select pin is set to
	// output, even if you don't use it:
	pinMode(CHIPSELECT,    OUTPUT);
	pinMode(DISPLAYBUTTON, OUTPUT);
	// see if the card is present and can be initialized:
	if (!SD.begin(CHIPSELECT, 11, 12, 13)) {
		error(INIT_ERROR);
	}
	printCenteredText("Creating file...", 2, WHITE, 320, 0, 188);

	char filename[15];
	strcpy(filename, "LOG0000.csv");
	for (uint8_t i = 0; i < 10000; i++) {
		filename[3] = '0' + (i/1000)%10;
		filename[4] = '0' + (i/100)%10;
		filename[5] = '0' + (i/10)%10;
		filename[6] = '0' + i%10;

		// create if does not exist, do not open existing, write, sync after write
		if (!SD.exists(filename)) {
			break;
		}
		logs = i+1;
	}

	// Open the file to write.
	logfile = SD.open(filename, FILE_WRITE);
	
	// If the file still doesn't exist,
	// or something else occurred.
	if (!logfile) error(FILE_ERROR);

	printCenteredText("Starting GPS...", 2, WHITE, 320, 0, 188);
	GPS.begin(9600);
	
	// Tell the GPS to send over all data.
	GPS.sendCommand(PMTK_SET_NMEA_OUTPUT_ALLDATA);

	// Set the update rate
	GPS.sendCommand(PMTK_SET_NMEA_UPDATE_1HZ); // 100 millihertz (once every 10 seconds), 1Hz or 5Hz update rate
	
	// Turn off updates on antenna status.
	GPS.sendCommand(PGCMD_NOANTENNA);

	GPS.sendCommand(PMTK_ENABLE_SBAS);
	GPS.sendCommand(PMTK_ENABLE_WAAS);

	// the nice thing about this code is you can have a timer0 interrupt go off
	// every 1 millisecond, and read data from the GPS for you. that makes the
	// loop code a heck of a lot easier!
	useInterrupt(true);
	display.fillScreen(backgroundColor);
	printTopBar();
	newGpsStatus.refresh = true;
	screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
	newGpsStatus.refresh = false;

}
// Interrupt is called once a millisecond, looks for any new GPS data, and stores it
SIGNAL(TIMER0_COMPA_vect) {
	char c = GPS.read();
	// if you want to debug, this is a good time to do it!
#ifdef UDR0
	if (GPSECHO)
		if (c) UDR0 = c;
	// writing direct to UDR0 is much much faster than Serial.print
	// but only one character can be written at a time.
#endif
}

void useInterrupt(boolean v) {
	if (v) {
		// Timer0 is already used for millis() - we'll just interrupt somewhere
		// in the middle and call the "Compare A" function above
		OCR0A = 0xAF;
		TIMSK0 |= _BV(OCIE0A);
		usingInterrupt = true;
	} else {
		// do not call the interrupt function COMPA anymore
		TIMSK0 &= ~_BV(OCIE0A);
		usingInterrupt = false;
	}
}

bool firstIteration = true;
void printTopBar() {
	display.setTextColor(backgroundColor);
	display.setTextSize(2);
	if (firstIteration)
	{
		display.setCursor(3,3);
		display.fillRect(0, 0, 320, 20, textColor);
		display.print(newDate.getDate());
		display.print("        ");
		display.print(newDate.getTime());
		firstIteration = false;
	} else {
		display.setTextSize(2);
		if (oldDate.day != newDate.day)
		{
			display.fillRect(3,3,10,14, textColor);
			display.fillRect(15,3,10,14, textColor);
			display.setCursor(3,3);

			if (GPS.day < 10) display.print("0");
			display.print(GPS.day);
		}

		if (oldDate.mth != newDate.mth)
		{
			display.fillRect(39,3,10,14, textColor);
			display.fillRect(51,3,10,14, textColor);
			display.setCursor(39,3);
			
			if (GPS.month < 10) display.print("0");
			display.print(GPS.month);
		}

		if (oldDate.yr != newDate.yr)
		{
			display.fillRect(99,3,10,14, textColor);
			display.fillRect(111,3,10,14, textColor);
			display.setCursor(99,3);
			
			if (GPS.year < 10) display.print("0");
			display.print(GPS.year, DEC);
		}

		if (oldDate.hr != newDate.hr)
		{
			display.fillRect(219,3,10,14, textColor);
			display.fillRect(231,3,10,14, textColor);
			display.setCursor(219,3);
			
			if (GPS.hour < 10) display.print("0");
			display.print(GPS.hour);
		}

		if (oldDate.min != newDate.min)
		{
			display.fillRect(255,3,10,14, textColor);
			display.fillRect(267,3,10,14, textColor);
			display.setCursor(255,3);
			
			if (GPS.minute < 10) display.print("0");
			display.print(GPS.minute);
		}

		if (oldDate.sec != newDate.sec || oldDate.mil != newDate.mil)
		{
			display.fillRect(291,3,10,14, textColor);
			display.fillRect(303,3,10,14, textColor);
			display.setCursor(291,3);
			int addSecs = GPS.seconds;
			if (GPS.milliseconds >= 500) addSecs++;
			
			if (addSecs < 10) display.print("0");
			display.print(addSecs);
		}
	}
}



void logPointToFile(DeviceAddress tempSensor) {
	// Print the current time.
	if (logfile.print(newDate.getISOTimestamp()) == 0)  error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the latitude
	if (logfile.print(GPS.latitudeDegrees,14) == 0)     error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the longitude
	if (logfile.print(GPS.longitudeDegrees,14) == 0)    error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the altitude
	if (logfile.print(GPS.altitude,14) == 0)            error(WRITE_ERROR);
	if (logfile.print(';') == 0)                        error(WRITE_ERROR);

	// Print the temperature.
	if (logfile.println(newGpsStatus.temperature) == 0) error(WRITE_ERROR);

	logfile.flush();
}

double distanceBetweenPoints(double lat1, double lat2, double lon1, double lon2) {
	int R = 6371; // km
	double dLat = (lat2-lat1)*PI/180;
	double dLon = (lon2-lon1)*PI/180;
	lat1 = lat1*PI/180;
	lat2 = lat2*PI/180;

	double a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1) * cos(lat2);
	double c = 2 * atan2(sqrt(a), sqrt(1-a));
	double d = R * c;

	return d;
}
TS_Point rotatePoint(uint8_t r, TS_Point p)
{
	int x = p.x, y = p.y;
	switch (r) {
		case 0:
			return p;
		case 1:
			p.x = y;
			p.y = SCREEN_HEIGHT - x;
			return p;
		case 2:

		case 3:
			p.x = p.y;
			p.y = p.x;
			return p;
	}
}
bool hasBeenPressed = false;
double oldLat = NULL, oldLon = NULL;
TS_Point pBegin, pEnd;

void refreshScreen() {
	display.fillScreen(backgroundColor);
	firstIteration = true;
	if(currentScreen != BLANK){
		printTopBar();
	}
	newGpsStatus.refresh = true;
	screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
	newGpsStatus.refresh = false;
}

void loop() {
	// if(ts.touched()) {
	// 	Serial.print("(");
	// 	Serial.print(rotatePoint(1, ts.getPoint()).x);
	// 	Serial.print(", ");
	// 	Serial.print(rotatePoint(1, ts.getPoint()).y);
	// 	Serial.println(")");
	// }

	if (ts.touched() && !hasBeenPressed) {
		hasBeenPressed = true;

		pBegin = pEnd = rotatePoint(1, ts.getPoint());
	} else if (ts.touched()) {
		pEnd = rotatePoint(1, ts.getPoint());
		oldCurrScreen = currentScreen;
	} else if (!ts.touched()) {

		if (hasBeenPressed) {
			if (currentScreen != SUMMARY)
			{
				if (currentScreen == SETTINGS) {
					if (20 < pBegin.x && pBegin.x < 70 && 50 < pBegin.y && pBegin.y < 100){
						textColor = GREEN;
						refreshScreen();

					}
					if (90 < pBegin.x && pBegin.x < 140 && 50 < pBegin.y && pBegin.y < 100) {
						textColor = BLUE;
						refreshScreen();
					}

					if (20 < pBegin.x && pBegin.x < 70 && 120 < pBegin.y && pBegin.y < 170){
						textColor = BLACK;
						refreshScreen();
					}
					if (90 < pBegin.x && pBegin.x < 140 && 120 < pBegin.y && pBegin.y < 170) {
						textColor = WHITE;
						refreshScreen();
					}

					if (20 < pBegin.x && pBegin.x < 70 && 190 < pBegin.y && pBegin.y < 240){
						textColor = RED;
						refreshScreen();
					}
					if (90 < pBegin.x && pBegin.x < 140 && 190 < pBegin.y && pBegin.y < 240) {
						textColor = YELLOW;
						refreshScreen();
					}


					// Background color
					if (160+20 < pBegin.x && pBegin.x < 210+20 && 50 < pBegin.y && pBegin.y < 100){
						backgroundColor = GREEN;
						refreshScreen();
					}
					if (160+90 < pBegin.x && pBegin.x < 210+90 && 50 < pBegin.y && pBegin.y < 100) {
						backgroundColor = BLUE;
						refreshScreen();
					}

					if (160+20 < pBegin.x && pBegin.x < 210+20 && 120 < pBegin.y && pBegin.y < 170){
						backgroundColor = BLACK;
						refreshScreen();
					}
					if (160+90 < pBegin.x && pBegin.x < 210+90 && 120 < pBegin.y && pBegin.y < 170) {
						backgroundColor = WHITE;
						refreshScreen();
					}

					if (160+20 < pBegin.x && pBegin.x < 210+20 && 190 < pBegin.y && pBegin.y < 240){
						backgroundColor = RED;
						refreshScreen();
					}
					if (160+90 < pBegin.x && pBegin.x < 210+90 && 190 < pBegin.y && pBegin.y < 240) {
						backgroundColor = YELLOW;
						refreshScreen();
					}


					if ((pBegin.x-pEnd.x) > 50 && (pEnd.x != 0 && pEnd.y != 240)) {
						currentScreen = SUMMARY;
					}
				} else {
					currentScreen = SUMMARY;
				}

			} else {
				for (int i = 1; i < 9; i++) {
					if (screens[i]->wasTapped(pBegin.x, pBegin.y)) {
						currentScreen = i;
						break;
					}
				}
			}
			if (oldCurrScreen != currentScreen) {
				refreshScreen();
			}
		}
		hasBeenPressed = false;
	}

	// if a sentence is received, we can check the checksum, parse it...
	if (GPS.newNMEAreceived()) {

		// a tricky thing here is if we print the NMEA sentence, or data
		// we end up not listening and catching other sentences!
		// so be very wary if using OUTPUT_ALLDATA and trying to print out data

		// Don't call lastNMEA more than once between parse calls!  Calling lastNMEA
		// will clear the received flag and can cause very subtle race conditions if
		// new data comes in before parse is called again.

		char *stringptr = GPS.lastNMEA();

		if (!GPS.parse(stringptr))   // this also sets the newNMEAreceived() flag to false
			return;  // we can fail to parse a sentence in which case we should just wait for another
			
		// Sentence parsed! Display updated data!
		if (strstr(stringptr, "RMC")) {
            if (GPS.speed*1.852 < 0.05) {
                GPS.speed = 0.0;
            }

			newDate.updateDate(GPS.year, GPS.month, GPS.day, GPS.hour, GPS.minute, GPS.seconds, GPS.milliseconds);
			newGpsStatus.updateStatus(GPS.speed*1.852, GPS.angle, GPS.altitude, GPS.HDOP, GPS.VDOP, GPS.PDOP, GPS.latitudeDegrees, GPS.longitudeDegrees, GPS.satellites, GPS.fix, GPS.satellitesInView, GPS.fixquality);
			printTopBar();
			if (newGpsStatus.fix) {
				if(!gotFix){
					currentScreen = SUMMARY;
					refreshScreen();
				}
				gotFix = true;
			}
		}

		// Disabling the temperature readings.
		// Read temperature from the sensor.
		//sensors.requestTemperatures();
		//double temp;
		//if (sensors.getAddress(tempDeviceAddress, 0)) {
		//	newGpsStatus.temperature = sensors.getTempC(tempDeviceAddress);
		//} else {
		//	newGpsStatus.temperature = NULL;
		//}

		// Update the max speed.
		if (newGpsStatus.speed > newGpsStatus.maxSpeed)
			newGpsStatus.maxSpeed = newGpsStatus.speed;

		newGpsStatus.acceleration = newGpsStatus.speed - oldGpsStatus.speed;


		// Calculate the distance between the old and new points.
		if (oldGpsStatus.lat != NULL && oldGpsStatus.lon != NULL) {
			newGpsStatus.distance += distanceBetweenPoints(oldGpsStatus.lat,
														   newGpsStatus.lat,
														   oldGpsStatus.lon,
														   newGpsStatus.lon);
			// This will do for now.
			newGpsStatus.avgSpeed = newGpsStatus.distance/newGpsStatus.points*60*60;
		}

		// Rad. lets log it! Only if the GPS has aquired a fix!
		if ((!(LOG_FIXONLY && !GPS.fix)) && strstr(stringptr, "RMC")){
			logPointToFile(tempDeviceAddress);
			newGpsStatus.points++;
		}
		if (strstr(stringptr, "RMC")) {
			// Display the selected screen.
			screens[currentScreen]->displayScreen(&newGpsStatus, &oldGpsStatus);
			// Do not refresh the elements that do not have to be refreshed again.
			newGpsStatus.refresh = false;

			oldGpsStatus = newGpsStatus;
			oldDate      = newDate;
		}

		
	}
}